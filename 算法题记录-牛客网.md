# 算法题记录-牛客网

## 写在前面：

```cpp
记录的代码并没有标明难度，也没有进行归类和排序。仅仅根据个人提交代码的时间做了一个粗略记录。方便自己复习。
```

## 算法注意事项

```cpp
int y = 0;//切记 一定要初始化啊 不然就会出错
```

## 常用Api

常用数据结构的api和特性要掌握（字符串、数组、向量、字典、栈、队列、链表、数等）

```cpp
输入、输出函数
比如一些字符串Api
字符串-整形 之间的切换 比如 int value = str[i] - '0'; or str[i] - 'A';
判断大消息
大小写切换
进制转换
截取子串
查询子串是否被包含
还有其他数据结构的api
```

```cpp
cin.get() == '\n' //获取cin输入的内容
```



### HJ32  密码截取

Catcher是MCA国的情报员，他工作时发现敌国会用一些对称的密码进行通信，比如像这些ABBA，ABA，A，123321，但是他们有时会在开始或结束时加入一些无关的字符以防止别国破解。比如进行下列变化 ABBA->12ABBA,ABA->ABAKK,123321->51233214　。因为截获的串太长了，而且存在多种可能的情况（abaaab可看作是aba,或baaab的加密形式），Cathcer的工作量实在是太大了，他只能向电脑高手求助，你能帮Catcher找出最长的有效密码串吗？

```cpp
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;

int getLen (string s, int l, int r) {
    while(l >= 0 && r < s.size() && s[l] == s[r]) {
        l--;
        r++;
    }
    return r - l - 1;
}

// 中心扩展法（单双中心取最大）
int main () {
    string s;
    cin >> s;
    int len = (int)s.size();
    if (len == 0) {
        cout << 0 << endl;
        return 0;
    }
    if (len == 1) {
        cout << 1 << endl;
        return 0;
    }
    int mS = 0;
    for (int i = 0; i < len - 1; ++i) {
        int m1 = getLen(s, i, i);
        int m2 = getLen(s, i, i + 1);
        mS = max(max(m1, m2), mS);
    }
    cout << mS << endl;
    return 0;
}

```

### HJ27  查找兄弟单词

定义一个单词的“兄弟单词”为：交换该单词字母顺序（注：可以交换任意次），而不添加、删除、修改原有的字母就能生成的单词。

兄弟单词要求和原来的单词不同。例如： ab 和 ba 是兄弟单词。 ab 和 ab 则不是兄弟单词。

现在给定你 n 个单词，另外再给你一个单词 x ，让你寻找 x 的兄弟单词里，按字典序排列后的第 k 个单词是什么？

注意：字典中可能有重复单词。

```cpp
//真不知道是考察算法 还是考察输入输出。。。。
//牛客网截止到目前存在bug，网页提交一直报错，最后重新加载网页后才提交成功。。。好坑
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>

using namespace std;

//参数说明
//wordNums 单词数量
//要查找的关键单词 keyWord
//关键单词在兄弟单词数组中的 第k个兄弟单词（如果存在的话）
void findBrotherWord(int wordNums) {
    //将输入的wordNums个单词存放到vecWord向量中
    vector<string>vecWord;
    for(int i = 0; i < wordNums; i++) {
        string str;
        cin >> str;
        vecWord.push_back(str);
    }
    //将输入的keyWord 存放起来
    string keyWord;
    cin >> keyWord;
    
    //将输入的keyIndex 存放起来
    int keyIndex;
    cin >> keyIndex;
    
    //开始查找是否存在兄弟单词，如果有兄弟单词，则将其存放到vecBRWord中
    vector<string>vecBRWord;
    string dicSortKeyWord = keyWord;
    sort(dicSortKeyWord.begin(), dicSortKeyWord.end());//将关键单词修改为【字典序】单词
    for(int i = 0; i < vecWord.size(); i++) {
        if(vecWord[i].size() == dicSortKeyWord.size()) {//兄弟单词 肯定长度要相同，但是两个单词彼此字母顺序不同
            if(vecWord[i] != keyWord) {//首先向量中的单词 和 关键单词 不相等
                string currentVecWord = vecWord[i];
                sort(currentVecWord.begin(), currentVecWord.end());
                if(currentVecWord == dicSortKeyWord) {//排列【字典序】后的向量中的单词和 【字典序】之后的 关键单词相等
                    vecBRWord.push_back(vecWord[i]);
                }
            }
        }
    }
    sort(vecBRWord.begin(), vecBRWord.end());//注意 这里用例要求都要输出，不要放到下面的if里。。。我也是醉了
    cout << vecBRWord.size() << endl;
    if(vecBRWord.size() > 0 && keyIndex < vecBRWord.size()) {//存在可以输出的兄弟单词
        cout << vecBRWord[keyIndex-1] << endl;
    }
}

int main() {
    int n;
    cin >> n;
    findBrotherWord(n);//本题的难点在于理解什么是【字典序】，以及如何求它，可以百度一下
    return 0;
}
```

### HJ69 矩阵乘法

如果A是个x行y列的矩阵，B是个y行z列的矩阵，把A和B相乘，其结果将是另一个x行z列的矩阵C。这个矩阵的每个元素是由下面的公式决定的

![img](https://www.nowcoder.com/equation?tex=%5Cbegin%7Bequation*%7D%0A%0AC_%7Bij%7D%20%3D%20%5Csum_%7Bk%3D0%7D%5E%7By-1%7DA_%7Bik%7D*B_%7Bkj%7D%0A%0A%5Cend%7Bequation*%7D%20(%E5%85%B6%E4%B8%AD0%20%5Cleq%20i%20%3C%20x%2C%200%20%5Cleq%20j%20%3C%20z))

矩阵的大小不超过100*100

```cpp
#include<iostream>
#include<string>
#include<vector>
using namespace std;

int main() {
    int x;//第一个矩形的行数
    cin >> x;
    
    int y;//第一个矩形的列数和第二个矩形的行数
    cin >> y;
    
    int z;//第二个矩形的列数
    cin >> z;
    
    int arrayOne[x][y];//构造第一个矩形数据
    for(int i = 0; i < x; i++) {//行
        for(int j = 0; j < y; j++) {//列
            int value;
            cin >> value;
            arrayOne[i][j] = value;
        }
    }
    
    int arrayTwo[y][z];//构造第二个矩形数据
    for(int i = 0; i < y; i++) {
        for(int j = 0; j < z; j++) {
            int value;
            cin >> value;
            arrayTwo[i][j] = value;
        }
    }
    
    //根据公式计算矩形结果
    int arrayThree[x][z];
    for(int i = 0; i < x; i++) {
        for(int j = 0; j < z; j++) {
            int sum = 0;
            for(int k = 0; k < y; k++) {
                sum += arrayOne[i][k] * arrayTwo[k][j];
            }
            arrayThree[i][j] = sum;
        }
    }
    
    for(int i = 0; i < x; i++) {
        for(int j = 0; j < z; j++) {
            cout << arrayThree[i][j] << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

### HJ2 计算某字符出现次数

写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字符，然后输出输入字符串中该字符的出现次数。（不区分大小写字母）

数据范围： ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%201000%20%5C)

```cpp
#include<iostream>
#include<string>
using namespace std;

int main() {
    string s;
    getline(cin, s);
    
    char c = tolower(getchar());
    
    int count = 0;
    for(auto i : s) {
        if(tolower(i) == c) {
            count++;
        }
    }
    cout << count << endl;
    return 0;
}
```

### HJ1 字符串最后一个单词的长度

计算字符串最后一个单词的长度，单词以空格隔开，字符串长度小于5000。（注：字符串末尾不以空格为结尾）

```cpp
#import <Foundation/Foundation.h>
int main(){
    char str[1000];
    scanf("%[^\n]",str);
    NSString *str2 = [NSString stringWithUTF8String:str];
    NSArray *strArr = [str2 componentsSeparatedByString:@" "];
    NSString *lastSubStr = [strArr lastObject];
    int len = (int)lastSubStr.length;
    printf("%d", len);
    return 0;
}
```

### HJ7 取近似值

写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于 0.5 ,向上取整；小于 0.5 ，则向下取整。

数据范围：保证输入的数字在 32 位浮点数范围内

```cpp
#import <Foundation/Foundation.h>
 
int main(int argc, char * argv[]) {
        float c;
        scanf("%f", &c);
        printf("%d",(int)(c+0.5));
    return 0;
}
```

### HJ24 合唱队

N 位同学站成一排，音乐老师要请最少的同学出列，使得剩下的 K 位同学排成合唱队形。

设![K](https://www.nowcoder.com/equation?tex=K)位同学从左到右依次编号为 1，2…，K ，他们的身高分别为![img](https://www.nowcoder.com/equation?tex=T_1%2CT_2%2C%E2%80%A6%2CT_K) ，若存在![img](https://www.nowcoder.com/equation?tex=i(1%5Cleq%20i%5Cleq%20K)) 使得![img](https://www.nowcoder.com/equation?tex=T_1%3CT_2%3C......%3CT_%7Bi-1%7D%3CT_i) 且 ![img](https://www.nowcoder.com/equation?tex=T_i%3ET_%7Bi%2B1%7D%3E......%3ET_K)，则称这![K](https://www.nowcoder.com/equation?tex=K)名同学排成了合唱队形。

通俗来说，能找到一个同学，他的两边的同学身高都依次严格降低的队形就是合唱队形。

例子：

123 124 125 123 121 是一个合唱队形

123 123 124 122不是合唱队形，因为前两名同学身高相等，不符合要求

123 122 121 122不是合唱队形，因为找不到一个同学，他的两侧同学身高递减。



你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

**注意：不允许改变队列元素的先后顺序** **且** **不要求最高同学左右人数必须相等**

数据范围： ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%203000%20%5C)

```cpp
#include<iostream>
#include<vector>
using namespace std;
 
int main()
{
    int n;
    while(cin >> n){
        // 输入的数组
        int tmp;
        vector<int> v;
        for (int i = 0; i < n; ++i){
            cin >>tmp;
            v.push_back(tmp);
        }
 
        // 最长递增子序列
        if (v.empty()) return 0;
        vector<int> dp1(n, 0);
        for (int i = 0; i < n; ++i){//从低位到高位遍历
            dp1[i] = 1;
            for(int j = 0; j <  i ; ++j){
                if (v[i] > v[j]){
                    dp1[i] = max(dp1[i], dp1[j]+1);
                }
            }
        }
 
        // 最长递减子序列
        vector<int> dp2(n, 0);
        for (int i = n - 1; i >= 0; --i){//从高位到低位遍历
            dp2[i] = 1;
            for (int j = n -1; j > i; --j){
                if (v[i] > v[j]){
                    dp2[i] = max(dp2[i], dp2[j]+1);
                }
            }
        }
 
        int maxLength = 0;
        for (int  i = 0; i < n; ++i){
            if (maxLength < dp1[i] + dp2[i] - 1){
                maxLength = dp1[i] + dp2[i] - 1;
                //这里的i就是划分中点
            }
        }
        cout << n - maxLength << endl;
    }
    return 0;
}
```

### NC121 字符串的排列 (就是全排列)

输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。

例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。

![img](https://uploadfiles.nowcoder.com/images/20211008/557336_1633676660853/6226390B4185DB132AFFDB10F09F8BEB)

数据范围：![img](https://www.nowcoder.com/equation?tex=n%20%3C%2010)
要求：空间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n!))，时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n!))

```cpp
class Solution {
public:
    void recursion(vector<string> &res, string &str, string &temp, vector<int> &vis){
        //临时字符串满了加入输出   
        if(temp.length() == str.length()){
            res.push_back(temp);
            return;
        }
        //遍历所有元素选取一个加入
        for(int i = 0; i < str.length(); i++){
            if(vis[i]){
                continue;//如果该元素已经被加入了则不需要再加入了
            }
            //当前的元素str[i]与同一层的前一个元素str[i-1]相同且str[i-1]已经用过了
            if(i > 0 && str[i-1] == str[i] && !vis[i-1]){
                continue;
            }
            //标记为使用过
            vis[i] = 1;
            //加入临时字符串
            temp.push_back(str[i]);
            recursion(res, str, temp, vis);
            //回溯
            vis[i] = 0;
            temp.pop_back();
        }
    }
    
    vector<string> Permutation(string str) {
        //先按字典序排列、使重复字符串相邻
        sort(str.begin(), str.end());
        //标记每个位置的字符串是否被使用过s
        vector<int> vis(str.size(), 0);//初始化向量vis，长度为str.size 初始值为0
        vector<string>res;
        string temp;
        //递归获取
        recursion(res, str, temp, vis);
        return res;
    }
};
```

### WY30 数字翻转

对于一个整数X，定义操作rev(X)为将X按数位翻转过来，并且去除掉前导0。例如:
如果 X = 123，则rev(X) = 321;
如果 X = 100，则rev(X) = 1.
现在给出整数x和y,要求rev(rev(x) + rev(y))为多少？

```cpp
#include<iostream>
using namespace std;

int rev(int x) {
    int res = 0;
    while(x){
        res *= 10;
        res += x%10;
        x /= 10;
    }
    return res;
}

int main() {
    int x,y;
    while(cin>>x>>y) {
        cout<<rev(rev(x) + rev(y))<<endl;
    }
}
```

### HJ29 字符串加解密

对输入的字符串进行加解密，并输出。

加密方法为：

当内容是英文字母时则用该英文字母的后一个字母替换，同时字母变换大小写,如字母a时则替换为B；字母Z时则替换为a；

当内容是数字时则把该数字加1，如0替换1，1替换2，9替换0；

其他字符不做变化。

解密方法为加密的逆过程。

数据范围：输入的两个字符串长度满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%201000%20%5C) ，保证输入的字符串都是只由大小写字母或者数字组成

```cpp
#include<iostream>
#include<string>
using namespace std;

string encrypt(string orStr) {
    int len = orStr.size();
    for(int i = 0; i < len; i++) {
        if(orStr[i] >= 'a' && orStr[i] <= 'y') {
            orStr[i] = orStr[i] - 32 + 1;
            continue;
        }
        if(orStr[i] >= 'A' && orStr[i] <= 'Y') {
            orStr[i] = orStr[i] + 32 + 1;
            continue;
        }
        if(orStr[i] == 'z') {
            orStr[i] = 'A';
            continue;
        }
        if(orStr[i] == 'Z') {
            orStr[i] = 'a';
            continue;
        }
        if ((orStr[i] >= '0') && (orStr[i] <= '8')) {
            orStr[i] += 1;
            continue;
        }
        if (orStr[i] == '9') {
            orStr[i] = '0';//真的很抠细节 这里不能写 0 写0的话 就错了，因为 0 是整型 不是 字符0
            continue;
        }
    }
    return orStr;
}

string decrypt(string str) {
    int len = str.size();
    for(int i = 0; i < len; i++) {
        if(str[i] >= 'b' && str[i] <= 'z') {
            str[i] = str[i] - 32 - 1;
            continue;
        }
        if (str[i] >= 'B' && str[i] <= 'Z') {
            str[i] = str[i] + 32 - 1;
            continue;
        }
        if (str[i] == 'a') {
            str[i] = 'Z';
            continue;
        }
        if (str[i] == 'A') {
            str[i] = 'z';
            continue;
        }
        if (str[i] >= '1' && str[i] <= '9') {
            str[i] -= 1;
            continue;
        }
        if (str[i] == '0') {
            str[i] = '9';//相当扣细节 这里也是 赋值的是字符 不是整型9
            continue;
        }
    }
    return str;
}

int main(){
    string orStr;
    cin >> orStr;
    cout << encrypt(orStr) << endl;
    
    string decryptStr;
    cin >> decryptStr;
    cout << decrypt(decryptStr) << endl;
    return 0;
}
```

### HJ26 字符串排序

编写一个程序，将输入字符串中的字符按如下规则排序。

规则 1 ：英文字母从 A 到 Z 排列，不区分大小写。

如，输入： Type 输出： epTy

规则 2 ：同一个英文字母的大小写同时存在时，按照输入顺序排列。

如，输入： BabA 输出： aABb

规则 3 ：非英文字母的其它字符保持原来的位置。



如，输入： By?e 输出： Be?y

数据范围：输入的字符串长度满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%201000%20%5C)

```cpp
#include<iostream>
#include<string>
#include<vector>
using namespace std;

int main() {
    string str;
    while(getline(cin, str)) {
        
    int len = str.size();
    vector<char>vec;
    for(int i = 0; i < 26; i++) {//26个字母，所以容器里最多需要26个空间[???不是大小写都有吗？？？]
        for(int j = 0; j < len; j++) {
            //将大小写字母转换成0～25对应的索引
            //注意 条件的 == i 是判断字母是否对应最外层for寻遍的顺序下标，这样向量中的元素就是升序的来
            if((str[j] - 'a' == i) || str[j] - 'A' == i) {//因为i是从0开始，所以这里是从0开始push
                vec.push_back(str[j]);//所以push的内容就是有序的，而且字母之外的数据就不会push进去
            }
        }
    }
    //i是字符的索引，k是向量的索引
    //依次将向量索引内的元素赋值给字符串，其余不满足条件的不是字母，所以不用赋值
    for(int i = 0, k = 0; (i < len) && (k < vec.size()); i++) {
        if((str[i] >= 'a' && str[i] <= 'z') || (str[i] >= 'A' && str[i] <= 'Z')) {
            str[i] = vec[k++];//只对字母进行排序后的赋值，其余字符就不会赋值了，结束循环就是结果
            //注意 这里的k++并没有放到i++旁边，因为k是vec的索引和str意义不同
        }
    }
    cout << str << endl;
    }
    return 0;
}
```

### HJ17 坐标移动

开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。

输入：

合法坐标为A(或者D或者W或者S) + 数字（两位以内）

坐标之间以;分隔。

非法坐标点需要进行丢弃。如AA10; A1A; $%$; YAD; 等。

下面是一个简单的例子 如：

A10;S20;W10;D30;X;A1A;B10A11;;A10;

处理过程：

起点（0,0）

\+  A10  = （-10,0）

\+  S20  = (-10,-20)

\+  W10 = (-10,-10)

\+  D30 = (20,-10)

\+  x  = 无效

\+  A1A  = 无效

\+  B10A11  = 无效

\+ 一个空 不影响

\+  A10 = (10,-10)

结果 （10， -10）

```cpp
#include<iostream>
#include<string>
#include<vector>
using namespace std;

void test(string str) {
    //A---left
    //D---right
    //W---up
    //S---down
    
    int x = 0;
    int y = 0;//切记 一定要初始化啊 不然就会出错
    //将字符串以 ; 分割， 并将元素放到向量中
    vector<string>vec;
    string location;//作为临时遍历存储每次获取到的坐标
    for(int i = 0; i<str.size(); i++) {
        if(str[i] != ';') {
            location += str[i];
        }
        if(str[i] == ';') {//当遇到连续的分号时 比如 ;; 那么这里的location就是空
          //所以，其实下面push的时候还可以判断一下，如果location长度为0就不push
            vec.push_back(location);//添加坐标
            location = "";//清除临时坐标，方便下次重新赋值
        }
    }
    
    //向量中的元素只有两种情况 要么是2位，要么是3位
    for(int i = 0; i < vec.size(); i++) {
        int move = 0;//移动的距离 只有正负值， 上下左右的方向对应  x的正负值 A和D   y的正负值 W和S
        string s = vec[i];
        if(s.size() == 3) {
            int ge = s[2] - '0';//将字符变成整形数据
            int shi = s[1] - '0';
            if((ge >=0 && ge <= 9) && (shi >= 0 && shi <= 9)) {
                move = shi*10 + ge;
            }
        } else if(s.size() == 2) {
            int ge = s[1] - '0';
            if(ge >= 0 && ge <= 9) {
                move = ge;
            }
        } else {
            continue;
        }
        switch(s[0]) {//取出坐标的第一个字符，它代表移动的方向
            case 'A': {
                x -= move;
                break;
            }
            case 'D': {
                x += move;
                break;
            }
            case 'W': {
                y += move;
                break;
            }
            case 'S': {
                y -= move;
                break;
            }
            default :
                break;
        }
    }
    cout << x << "," << y << endl;
}

int main() {
    string str;
    while(cin >> str) {
        test(str);
    }
    return 0;
}
```

HJ3 明明的随机数

明明生成了![N](https://www.nowcoder.com/equation?tex=N)个1到500之间的随机整数。请你删去其中重复的数字，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。

```cpp
#include<iostream>
#include<map>
#include<vector>
using namespace std;

int main() {
    int N;
    cin >> N;//随机数个数
    int random;//每一行输入一个随机数 输入N个
    
    map<int, int>tMap;
    int count = 0;
    while(cin >> random) {//接收N个随机数，并将其对应的值作为key添加到map
        tMap[random]++;
        count++;
        if(count == N)break;
    }
    
    vector<int>vec;
    for(auto m:tMap) {//遍历map 拿到所有的key 也就是所有的随机数 没有重复的
        vec.push_back(m.first);
    }
    
    
    for(int i = 0; i < vec.size(); i++) {//对随机数进行遍历, 从小到大进行排列
        for(int j = i + 1; j < vec.size(); j++) {//傻逼了 太久没有做题了 这里的 j = i + 1 之前写成 j = 1了
            if(vec[i] > vec[j]) {
                int t = vec[i];
                vec[i] = vec[j];
                vec[j] = t;
            }
        }
    }
    
    for(int i = 0; i < vec.size(); i++) {
        cout << vec[i] << endl;
    }
    
    return 0;
}
```

### HJ20 密码验证合格程序

密码要求:

1.长度超过8位

2.包括大小写字母.数字.其它符号,以上四种至少三种

3.不能有长度大于2的包含公共元素的子串重复 （注：其他符号不含空格或换行）

数据范围：输入的字符串长度满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%20100%20%5C)

```cpp
#include<iostream>
#include<string>
using namespace std;

int main() {
    string str;
    cin >> str;
    
    if(str.size() < 8) {
        cout << "NG" << endl;
        return 0;
    }
    
    for(int i = 0; i < str.size(); i++) {
        if(str[i] == ' ' || str[i] == '\n') {
            cout << "NG" << endl;
            return 0;
        }
    }
    
    for(int i = 0; i+3< str.size(); i++) {
        for(int j = i+3; j+3<str.size(); j++) {
            if(str.substr(i, 3) == str.substr(j, 3)) {
                cout << "NG" << endl;
                return 0;
            }
        }
    }
    
    cout << "OK" << endl;
    return 0;
}
```

### HJ53 杨辉三角的变形

![img](https://uploadfiles.nowcoder.com/images/20210617/557336_1623898240633/9AC4B89B5E22854D71DEA4CA6EBD6F9F)

以上三角形的数阵，第一行只有一个数1，以下每行的每个数，是恰好是它上面的数、左上角数和右上角的数，3个数之和（如果不存在某个数，认为该数就是0）。

求第n行第一个偶数出现的位置。如果没有偶数，则输出-1。例如输入3,则输出2，输入4则输出3，输入2则输出-1。

数据范围： ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%2010%5E9%20%5C)

```cpp
#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    //这就很坑爹了 居然是一个找规律的题。原本想的时候如何构造一个指定为n的矩阵，然后再去查找元素是否符合 符合就输出 并结束。。。是我想太多
    if(n <= 2) {
        cout << -1 << endl;
    } else if(n%4==3 ||n%4==1) {
        cout << 2 << endl;
    } else if(n%4 == 0) {
        cout << 3 << endl;
    } else {
        cout << 4 << endl;
    }
    return 0;
}
```

### HJ40 统计字符

输入一行字符，分别统计出包含英文字母、空格、数字和其它字符的个数。

数据范围：输入的字符串长度满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%201000%20%5C)

```cpp
#include<iostream>
#include<string>
using namespace std;

int main() {
    string str;

    while(getline(cin, str)) {
        int len = str.size();

        int a = 0;
        int b = 0;
        int c = 0;
        int d = 0;
        for(int i = 0; i < len; i++) {
            if((str[i] >= 'a' && str[i] <= 'z') || (str[i] >= 'A' && str[i] <= 'Z')) {
                a++;
            } else if(str[i] == ' ') {
                b++;
            } else if(str[i] >= '0' && str[i] <= '9') {
                c++;
            } else {
                d++;
            }
        }
        cout << a << endl;
        cout << b << endl;
        cout << c << endl;
        cout << d << endl;
    }
    return 0;
}
```

### HJ37 统计每个月兔子的总数

有一种兔子，从出生后第3个月起每个月都生一只兔子，小兔子长到第三个月后每个月又生一只兔子。

例子：假设一只兔子第3个月出生，那么它第5个月开始会每个月生一只兔子。

一月的时候有一只兔子，假如兔子都不死，问第n个月的兔子总数为多少？

数据范围：输入满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%2031%20%5C)

```cpp
#include<iostream>
#include<vector>
#include<map>
using namespace std;

int func(int n) {
    return n<3?1:func(n-1)+func(n-2);
}

int main() {
    int n;
    cin >> n;
    cout << func(n) << endl;
    return 0;
}
```

### HJ35 蛇形矩阵

蛇形矩阵是由1开始的自然数依次排列成的一个矩阵上三角形。

例如，当输入5时，应该输出的三角形为：

1 3 6 10 15
2 5 9 14
4 8 13
7 12
11

```cpp
#include<iostream>
#include<string>
#include<vector>
using namespace std;

int main() {
    int num;
    cin >> num;
    
    //vector<vector<int>>vec(num, vector<int>(num, 0)); 定义一个num阶矩阵
    vector<vector<int>>vec;
    for(int i = 0; i < num; i++) {
        vector<int>t;
        for(int j = 0; j < num; j++) {
            t.push_back(0);
        }
        vec.push_back(t);
    }
    
    int value = 1;
    for(int i = 0; i < num; i++) {
        int j = i;//行
        int k = 0;//列
        
        while(j >= 0) {
            vec[j][k] = value;
            j--;
            k++;
            value++;
        }
    }
    
    for(int i = 0; i < num; i++) {
        for(int j = 0; j < num; j++) {
            if(vec[i][j] != 0) {
                cout << vec[i][j] << " ";
            }
        }
        cout << endl;
    }
        
    return 0;
}
```

### HJ34 图片整理

Lily上课时使用字母数字图片教小朋友们学习英语单词，每次都需要把这些图片按照大小（ASCII码值从小到大）排列收好。请大家给Lily帮忙，通过代码解决。

Lily使用的图片使用字符"A"到"Z"、"a"到"z"、"0"到"9"表示。

数据范围：每组输入的字符串长度满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%201000%20%5C)

```cpp
#include<iostream>
#include<string>
using namespace std;

int main() {
    string str;
    cin >> str;
    int len = str.size();
    
    for(int i = 0; i < len; i++) {
        for(int j = i+1; j < len; j++) {
            if(str[i] > str[j]){
                char t = str[i];
                str[i] = str[j];
                str[j] = t;
            }
        }
    }
    cout << str << endl;
    return 0;
}
```

### HJ31 单词倒排

对字符串中的所有单词进行倒排。

说明：

1、构成单词的字符只有26个大写或小写英文字母；

2、非构成单词的字符均视为单词间隔符；

3、要求倒排后的单词间隔符以一个空格表示；如果原字符串中相邻单词间有多个间隔符时，倒排转换后也只允许出现一个空格间隔符；

4、每个单词最长20个字母；

数据范围：字符串长度满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%2010000%20%5C)

```cpp
#include<iostream>
#include<string>
#include<vector>
using namespace std;

void test(string str) {
    vector<string> vec;//用向量来存储单词
    int len = str.size();//获取字符串的长度
    int sublen = 0;//记录每个子串（单词）的长度
    //将句子中的单词分割，并将最后一个单词之外的单词写入向量（当句子包含多个单词时）
    for(int i = 0; i < len; i++) {
        if((str[i] >= 'a' && str[i] <= 'z') || str[i] >= 'A' && str[i] <= 'Z') {
            sublen++;
        } else {
            if(sublen > 0) {
                vec.push_back(str.substr(i - sublen, sublen));//将单词写入向量
                sublen = 0;//重置单词的长度，记录下一个单词的长度
            }
        }
    } 
    //将最后一个单词写入向量，当句子仅有一个单词时也适用
    if(sublen > 0) {
        vec.push_back(str.substr(len - sublen, sublen));
    }
    //倒序输出单词，并用空格隔开，形成单词倒排的句子
    for(int i = vec.size() - 1; i > 0; i--) {
        cout << vec[i] << ' ';
    }
    cout << vec[0] << endl;
}

int main() {
    string  str;
    while(getline(cin, str)) {
        test(str);
    }
    return 0;
}
```

### HJ23  删除字符串中出现次数最少的字符

实现删除字符串中出现次数最少的字符，若出现次数最少的字符有多个，则把出现次数最少的字符都删除。输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。

数据范围：输入的字符串长度满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%2020%20%5C) ，保证输入的字符串中仅出现小写字母

```cpp
#include<iostream>
#include<string>
using namespace std;

string delStr(string str) {
    /*
    说一下牛客上大佬的思路
    定义一个数组，存在所有的输入字母，重复的就在其下标balue上++，这样就记录了字符和字符出现的次数
    然后在遍历输入字符串，对遍历到的字符去数组里看一下是不是出现次数最少的，是就删除调。删除不太好实现，可以反过来
    在遍历输入字符串时，对遍历到的字符串去数组里看一下是不是不是出现次数最少的，是就累加，这样就删除调出现次数最少的字符了，然后返回结果
    */
    string res;
    int len = (int)str.size();
    int zimuArr[26] = {0};//为什么这里用len来设置数组的长度会报错？
    int min = INT32_MAX;
    //遍历字符串中的每一个元素，然后将元素换算成0~25的下标，存储到数组中，并对重复出现的字符的value++
    for(int i = 0; i < len; i++) {
        zimuArr[str[i] - 'a'] += 1;
    }
    
    //获取字符串中出现次数最少的字符的次数 有点绕，但是就是这个意思
    for(int i = 0; i < 26; i++) {//注意 由于这里的zimuArr的索引并不是str.size的范围，由上一个for循环可知 zimuArr的索引是 str[i] - 'a' 这个值最大是25
        if((zimuArr[i] <= min) && (zimuArr[i] != 0)) {
            min = zimuArr[i];
        }
    }
    
    //计算出不包含最小出现次数字符的字符串
    for(int i = 0; i < len; i++) {
        if(zimuArr[str[i] - 'a'] > min) {
            res += str[i];//注意 这里是用str[i]累加，可不是zimuArr 后者存放的是int数量
        }
    }
    return res;
}

int main() {
    string str;
    cin >> str;
    cout << delStr(str) << endl;
    return 0;
}
```

### HJ22 汽水瓶

某商店规定：三个空汽水瓶可以换一瓶汽水，允许向老板借空汽水瓶（但是必须要归还）。

小张手上有n个空汽水瓶，她想知道自己最多可以喝到多少瓶汽水。

数据范围：输入的正整数满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%20100%20%5C)

注意：本题存在多组输入。输入的 0 表示输入结束，并不用输出结果。

```cpp
#include<iostream>
using namespace std;


int main() {
    int n;
    while(cin >> n) {// 输入测试数据
        if(n != 0) {
            cout << n/2 << endl;//输出结果
        }
    }
    return 0;
}
```

### HJ21  简单密码

现在有一种密码变换算法。

九键手机键盘上的数字与字母的对应： 1--1， abc--2, def--3, ghi--4, jkl--5, mno--6, pqrs--7, tuv--8 wxyz--9, 0--0，把密码中出现的小写字母都变成九键键盘对应的数字，如：a 变成 2，x 变成 9.

而密码中出现的大写字母则变成小写之后往后移一位，如：X ，先变成小写，再往后移一位，变成了 y ，例外：Z 往后移是 a 。

数字和其它的符号都不做变换。

数据范围： 输入的字符串长度满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%20100%20%5C)

```cpp
#include<iostream>
using namespace std;

int main() {
    string str;
    cin >> str;
    
    int len = str.size();
    string res;
    for(int i = 0; i < len; i++) {
        if(str[i] >= '0' && str[i] <= '9') {
            res += str[i];
        }
        if(str[i] >= 'A' && str[i] <= 'Z') {
            if(str[i] == 'Z') {
                res += 'a';
            } else {
                res += str[i] + 32 + 1;//注意 这里是 + 32，因为大写字母比对应的小写字母相差32，所以+32可以将大写转为小写，再+1 即可得到小写字母的下一个
            }
        }
        if(str[i] >= 'a' && str[i] <= 'z') {
            if(str[i] >= 'a' && str[i] <= 'c') {
                res += '2';
            }
            if(str[i] >= 'd' && str[i] <= 'f') {
                res += '3';
            }
            if(str[i] >= 'g' && str[i] <= 'i') {
                res += '4';
            }
            if(str[i] >= 'j' && str[i] <= 'l') {
                res += '5';
            }
            if(str[i] >= 'm' && str[i] <= 'o') {
                res += '6';
            }
            if(str[i] >= 'p' && str[i] <= 's') {
                res += '7';
            }
            if(str[i] >= 't' && str[i] <= 'v') {
                res += '8';
            }
            if(str[i] >= 'w' && str[i] <= 'z') {
                res += '9';
            }
        }
    }
    cout << res;
    return 0;
}
```

### HJ15 求int型正整数在内存中存储时1的个数

输入一个 int 型的正整数，计算出该 int 型数据在内存中存储时 1 的个数。

数据范围：保证在 32 位整型数字范围内

```cpp
#include<iostream>
using namespace std;

int main() {
    int num;
    cin >> num;
    int m = 0;
    while(num) {
        m += num % 2;//二进制的表示 2的n次方(n从0~最高位往左数)*0或1 每一项都是如此相加得到十进制的结果 可参考：https://zhidao.baidu.com/question/133893254.html
        num /= 2;
    }
    cout << m;
}
```

### HJ14 字符串排序

给定 n 个字符串，请对 n 个字符串按照字典序排列。

数据范围： ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%201000%20%5C) ，字符串长度满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20len%20%5Cle%20100%20%5C)

```cpp
#include<iostream>
#include<string>
#include<vector>
using namespace std;

int main() {
    int num;
    cin >> num;
    int count = num;
    vector<string>vec;
    while(count) {
        count--;
        string str;
        cin >> str;
        vec.push_back(str);
    }
    
    for (int i = 0; i < num; i++) {
        for(int j = i + 1; j < num; j++) {
            string a = vec[i];
            string b = vec[j];
            if(a > b) {
                vec[i] = b;
                vec[j] = a;
            }
        }
    }
    for(int i = 0; i < num; i++) {
        cout << vec[i] << endl;
    }
    return 0;
}
```

### HJ13 句子逆序

将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”

所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符

数据范围：输入的字符串长度满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%201000%20%5C)

注意本题有多组输入

```cpp
#include<iostream>
#include<string>
#include<stack>
using namespace std;



int main() {
    string s;
    stack<string>tmp;
    while(cin >> s) {//目前没有搞明白 为什么这里输入的一句话 会以空格自动间隔开 进入循环 与cin函数有关
        tmp.push(s);
    }
    while(!tmp.empty()) {
        cout << tmp.top() << " ";//每次都从栈顶取出元素输出 并添加一个空格，其实我觉得这样不对，因为最后一个单词的前面是没有空格的，但是用例却通过了。。。
        tmp.pop();
    }
    return 0;
}
```

### HJ12 字符串反转

接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）

```cpp
#include<iostream>
#include<string>
using namespace std;

int main() {
    string str;
    cin >> str;
    
    int len = str.size();
    string res;
    for(int i = len -1; i >= 0; i--) {
        res += str[i];
    }
    cout << res << endl;
    return 0;
}
```

### HJ11 数字颠倒

输入一个整数，将这个整数以字符串的形式逆序输出

程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001

数据范围： ![img](https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%20%202%5E%7B30%7D-1%20%5C)

```cpp
#include<iostream>
#include<string>
using namespace std;

int main() {
    int num;
    cin >> num;
    string numStr = to_string(num);//将输入数字直接转成字符串
    
    int len = numStr.size();
    string res;
    for(int i = len -1; i >= 0; i--) {//对字符串进行逆序遍历，然后依次累加得到结果
        res += numStr[i];
    }
    cout << res << endl;
}
```

### HJ10 字符个数统计

编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0~127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次

例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。

```cpp
#include<iostream>
#include<string>
#include<map>
using namespace std;

int main() {
    string str;
    cin >> str;
    int len = str.size();
    map<char, int>cMap;
    int count = 0;
    
    for(int i = 0; i < len; i++) {
        if(str[i] >= 0 && str[i] <= 127) {
            cMap[str[i]]++;   
        }
    }
    count = cMap.size();//只需要统计key的数量就可以了
    cout << count << endl;
}
```

### HJ9 提取不重复的整数

输入一个 int 型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。

保证输入的整数最后一位不是 0 。

```cpp
#include<iostream>
#include<map>
using namespace std;


int main() {
    int num;
    cin >> num;
    string numStr = to_string(num);//将输入的整型转为字符串
    int len = numStr.size();
    map<int, int>numMap;
    int resNum = 0;
    
    for(int i = len -1; i >= 0; i--) {
        //注意这里的 numStr[i] - '0' 它的意思是将一个整型字符转换成一个对应的整型数据
        //如果我们强制转换整型字符 (int)numStr[i] 将得到对应字符的ascii码，而不是预期结果， 所以这里要用【减法】即将当前字符的ascii码-'0'对应的asscii码 将得到对应的整型数
        numMap[numStr[i] - '0']++;
    }
    
    for(int i = len -1; i >= 0; i--) {
        if(numMap[numStr[i] - '0'] >= 1) {
            resNum *= 10;
            resNum += numStr[i] - '0';//这里巧妙的累乘10，这样就可以达到每次添加的数都是各位，而之前的结果递增10的效果
            numMap[numStr[i] - '0'] = 0;//注意 这里删除了已经累加的key，避免重复
        }
    }
    cout << resNum << endl;
    return 0;
}
```

### HJ8 合并表记录

数据表记录包含表索引index和数值value（int范围的正整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照index值升序进行输出。

```cpp
#include<iostream>
#include<map>
using namespace std;

int main(){
    int n;
    cin >> n;
    map<int ,int> kv;
    while(n) {
        int k, v;
        cin >> k;
        cin >> v;
        kv[k] += v;
        n--;
    }
    for(auto [k, v]:kv){//不知道这里是什么意思， [k, v] 不知道是什么意思
        cout << k << " " << v << endl;//为什么这里就顺序遍历了
    }
}
```

### HJ6  质数因子

功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5 ）

```cpp
#include<iostream>
#include<cmath>
using namespace std;

int main() {
    long enterNum;
    long old_n = 0;
    cin >> enterNum;
    while(enterNum != 1) {
        for(int i = 2; i <= sqrt(enterNum); i++) {
            old_n = enterNum;
            while(enterNum % i == 0) {
                cout << i << " ";
                enterNum /= i;
            }
            if(old_n != enterNum) {
                break;//?
            }
        }
        if(old_n == enterNum) {
            cout << enterNum << ' ';
            break;
        }
    }
    return 0;
}
```

### HJ5 进制转换

写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。

```cpp
#include<iostream>
#include<string>
#include<cmath>
using namespace std;

int main() {
    string s;
    while(cin >> s) {//连续读取字符串
        int bit = 0;//记录当前位数
        int res = 0;//
        for(int i = s.size() -1; i > 1; i--) {
            if(s[i] >= '0' && s[i] <= '9') {
                res += (s[i] - '0') * pow(16, bit);//当前数字乘16的位数次方
                bit++;
            }
            else if(s[i] >= 'A' && s[i] <= 'F') {
                res += (s[i] - 'A' + 10) * pow(16, bit);//字母要转化成数字
                bit++;
            }
        }
        cout << res << endl;
        return 0;
    }
}
```

### HJ4 字符串分隔

•输入一个字符串，请按长度为8拆分每个输入字符串并进行输出；

•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。

```cpp
#include<iostream>
#include<string>
using namespace std;

int main() {
    string str;
    while(getline(cin, str)) {
        while(str.size() > 8) {
            cout << str.substr(0, 8) << endl;
            str = str.substr(8, str.size()-8);
        }
        int len = str.size();
        if(len == 8) {
            cout << str << endl;
        } else {
            for(int i = len; i < 8; i++) {
                str += '0';
            }
            cout << str << endl;
        }
    }
    return 0;
}
```

### HJ2 计算某字符出现次数

写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字符，然后输出输入字符串中该字符的出现次数。（不区分大小写字母）

```cpp
#include<iostream>
#include<string>
using namespace std;
//注意 不区分大小写 所以ascll码 +32一样也++

int main() {
    string s;
    getline(cin, s);
    char c = tolower(getchar());
    
    int n = 0;
    for(auto i : s) {
        if(tolower(i) == c) {
            ++n;
        }
    }
    cout << n << endl;
    return 0;
}
```

### HJ1 字符串最后一个单词的长度

计算字符串最后一个单词的长度，单词以空格隔开，字符串长度小于5000。（注：字符串末尾不以空格为结尾）

```cpp
#include<iostream>
#include<string>
using namespace std;

int main() {
    string s;
    while(getline(cin, s)) {
        size_t pos = s.rfind(' ');
        cout << s.size()- pos-1 << endl;
    }
}
```

### NC55 最长公共前缀

给你一个大小为 n 的字符串数组 strs ，其中包含n个字符串 , 编写一个函数来查找字符串数组中的最长公共前缀，返回这个公共前缀。

数据范围： ![img](https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%205000%20)， ![img](https://www.nowcoder.com/equation?tex=0%20%5Cle%20len(strs_i)%20%5Cle%205000%20)

进阶：空间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n))，时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n))

```cpp
class Solution {
public:
    /**
     * 
     * @param strs string字符串vector 
     * @return string字符串
     */
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty()) {
        return "";
    }
    //首先找出最小的字符串，公共前缀最大就是最小字符串的大小
    string minStr = strs[0];
    for(int i = 1; i < strs.size(); i++) {
        if(strs[i].size() < minStr.size()) {
            minStr = strs[i];
        }
    }
    //我们将字符串数组看成一个二维的字符数组，后依次一列，一列的对字符进行比较
    string ans = "";
    int cow = (int)minStr.size();//列数是最小字符串的长度
    int row = (int)strs.size();//统计有多少行
    for(int c = 0; c < cow; c++) {
        for(int r = 0; r < row; r++) {
            char cuChar = strs[r][c];
            char minStrChar = minStr[c];
            if(cuChar != minStrChar) {
                return ans;//如果某一列字符与最小字符串中对应列的字符不同 则返回结果，不再比较
            }
        }
        //比较完一列数据未发现不同，则追加字符到结果中
        ans += minStr[c];
        
    }
    return ans;
    }
};
```

### NC89 字符串变形

对于一个长度为 n 字符串，我们需要对它做一些变形。

首先这个字符串中包含着一些空格，就像"Hello World"一样，然后我们要做的是把这个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。

比如"Hello World"变形后就变成了"wORLD hELLO"。

数据范围: ![img](https://www.nowcoder.com/equation?tex=1%5Cle%20n%20%5Cle%2010%5E6) , 字符串中包括大写英文字母、小写英文字母、空格。

进阶：空间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n)) ， 时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n))

```cpp
class Solution {
public:
    string trans(string s, int n) {
        /*
        思路：要求 输入 Hello World --返回--> wORLD hELLO
        要对单词逆序，然后要对单词转换大小写
        1、首先思考怎么对单词逆序
        2、其次是怎么转换大小写
        3、然后就是实现部分了
        */
        int charIndex = n - 1;//长度为n的字符串，但是字符数组从0开始,索引范围是 0～n-1
        int charArrLen = n - 1;
        string ans;//返回的结果 Hello World ---> wORLD hELLO
        for(int i = charArrLen; i >= 0; i--) {//反向遍历原字符串
            if(s[i] == ' ') {//如果遍历到空格，说明前面遍历的内容是一个单词
                for(int j = i + 1; j <= charIndex; j++) {//i+1 是因为当前的i时一个空格，空格后面才是单词的第一个字符
                    ans += transChar(s[j]);//从j～charIndex是单词的长度，后面会修改这个charIndex的值
                }
                ans += ' ';//间隔单词
                charIndex = i - 1;//当一个单词遍历结束后，当前的i还在空格的位置，i-1的意思是 charIndex向左移动一个单位，定位到下一个单词的头部
            }
        }
        //注意！由于‘ ’的判断会漏掉最后一个单词，所以最后一个单词还需要单独处理
        for(int i = 0; i <= charIndex; i++) {
            ans += transChar(s[i]);
        }
        return ans;
    }
    
    //由于大小写之间的值相差32， a:97 A:65   a-A == 32
    //所以小写转大写 要减去32 即 ch - ‘a’ + 'A' == ch - 32
    //所以大写转小写 要加上32 即 ch - ‘A’ + 'a' == ch - 32
    //当然你也可以直接 + - 32 来计算
    char transChar(char ch) {
        if(ch >='a' && ch <= 'z') {//当前字符为小写
            return ch - 'a' + 'A';//返回大写的ch
        } else {
            return ch - 'A' + 'a';//返回小写的ch
        }
    }
};
```

### NC13 求二叉树的层序遍历

给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）
例如：
给定的二叉树是{3,9,20,#,#,15,7},
![img](https://uploadfiles.nowcoder.com/images/20210114/999991351_1610616074120/036DC34FF19FB24652AFFEB00A119A76)
该二叉树层序遍历的结果是
[
[3],
[9,20],
[15,7]

]

数据范围：二叉树的节点数满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20n%20%5Cle%2010%5E5%20%5C)

```cpp
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode* root) {
        vector<vector<int>>res;
        levelSort(root, 0, res);
        return res;
    }
    void levelSort(TreeNode* root, int level, vector<vector<int>>& vec) {
        if(root == nullptr) return;
        if(level >= vec.size()) {//最新的深度，申请一个数组存储
            vec.push_back(vector<int>{});
        }
        vec[level].push_back(root->val);
        levelSort(root->left, level+1, vec);
        levelSort(root->right, level+1, vec);
    }
};
```

### NC13 二叉树的最大深度

求给定二叉树的最大深度，

深度是指树的根节点到任一叶子节点路径上节点的数量。

最大深度是所有叶子节点的深度的最大值。

（注：叶子节点是指没有子节点的节点。）

数据范围：![img](https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%20100000)，树上每个节点的val满足 ![img](https://www.nowcoder.com/equation?tex=%7Cval%7C%20%5Cle%20100)
要求： 时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n))

```cpp
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr)return 0;
        int l = maxDepth(root->left);
        int r = maxDepth(root->right);
        return l>r?(l+1):(r+1);
    }
};
```

### NC193  二叉树的前序遍历

给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

数据范围：二叉树的节点数量满足 ![img](https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%20100%20%20%5C) ，二叉树节点的值满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20val%20%5Cle%20100%20%5C) ，树的各节点的值各不相同

示例 1：![img](https://uploadfiles.nowcoder.com/images/20211111/392807_1636599059575/FE67E09E9BA5661A7AB9DF9638FB1FAC)

```cpp
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return int整型vector
     */
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int>res;
        centerSort(root, res);
        return res;
    }
    
    //前序遍历 中-左-有    
    void centerSort(TreeNode* node, vector<int>& vec) {
        if(node == nullptr) {
            return;//递归边界
        }
        vec.push_back(node->val);//中
        centerSort(node->left, vec);//左
        centerSort(node->right, vec);//右
    }
};
```



### NC161 二叉树的中序遍历

给定一个二叉树的根节点root，返回它的中序遍历结果。

数据范围：树上节点数满足 ![img](https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%201000)，树上每个节点的值满足 ![img](https://www.nowcoder.com/equation?tex=0%20%5Cle%20val%20%5Cle%201000)
进阶：空间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n))，时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n))

```cpp
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int>res;
        centerSort(root, res);
        return res;
    }
    //中序遍历 左、中、右
    void centerSort(TreeNode* node, vector<int>& vec) {
        if(node == nullptr) {
            return;
        }
        centerSort(node->left, vec);
        vec.push_back(node->val);
        centerSort(node->right, vec);
    }
};
```

### NC192 二叉树的后序遍历

给定一个二叉树，返回他的后序遍历的序列。

后序遍历是值按照 左节点->右节点->根节点 的顺序的遍历。

数据范围：二叉树的节点数量满足 ![img](https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%20100%20%20%5C) ，二叉树节点的值满足 ![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20val%20%5Cle%20100%20%5C) ，树的各节点的值各不相同

样例图

![img](https://uploadfiles.nowcoder.com/images/20211111/392807_1636596692486/64547759EAC75079FDBF501CAA589890)

```cpp
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return int整型vector
     */
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int>res;
        backSort(root, res);
        return res;
    }
    void backSort(TreeNode* tree, vector<int>& vec) {
        //左右中
        if(tree == nullptr){
            return;
        }
        backSort(tree->left, vec);
        backSort(tree->right, vec);
        vec.push_back(tree->val);
    }
};
```

### NC25 删除有序链表中重复的元素-I

删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次
例如：
给出的链表为![img](https://www.nowcoder.com/equation?tex=1%5Cto1%5Cto2),返回![img](https://www.nowcoder.com/equation?tex=1%20%5Cto%202).
给出的链表为![img](https://www.nowcoder.com/equation?tex=1%5Cto1%5Cto%202%20%5Cto%203%20%5Cto%203),返回![img](https://www.nowcoder.com/equation?tex=1%5Cto%202%20%5Cto%203).

数据范围：链表长度满足 ![img](https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%20100)，链表中任意节点的值满足 ![img](https://www.nowcoder.com/equation?tex=%7Cval%7C%20%5Cle%20100)

进阶：空间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(1))，时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n))

```cpp
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* p = head;
        if(p == NULL) {
            return head;
        }
        while(p->next != NULL) {
            if(p->val == p->next->val) {
                p->next = p->next->next;//删除节点
            } else {
                p = p->next;
            }
        }
        return head;
    }
};
```

### NC96 判断一个链表是否为回文结构

给定一个链表，请判断该链表是否为回文结构。

回文是指该字符串正序逆序完全一致。

数据范围： 链表节点数 ![img](https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%2010%5E5)，链表中每个节点的值满足 ![img](https://www.nowcoder.com/equation?tex=%7Cval%7C%20%5Cle%2010%5E7)

```cpp
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 the head
     * @return bool布尔型
     */
    bool isPail(ListNode* head) {
        string str1;
        string str2;
        ListNode* p = head;
        while(p) {
            str1 = str1 + (char)p->val;
            str2 = (char)p->val + str2;
            p = p->next;
        }
        return str1 == str2;//c++字符串是否相等用==
    }
};
```

### NC66 两个链表的第一个公共结点

输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

数据范围： ![img](https://www.nowcoder.com/equation?tex=n%20%5Cle%201000)
要求：空间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(1))，时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n))

例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211104/423483716_1635999204882/394BB7AFD5CEA3DC64D610F62E6647A6)

可以看到它们的第一个公共结点的结点值为6，所以返回结点值为6的结点。

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode* p = pHead1;
        map<ListNode*, int>sameMap;
        while(p) {
            sameMap[p] = 1;
            p = p->next;
        }
        p = pHead2;
        while(p) {
            if(sameMap[p]) {
                return p;
            }
            p = p->next;
        }
        return NULL;
    }
};
```

### NC69 链表中倒数最后k个结点

输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。

如果该链表长度小于k，请返回一个长度为 0 的链表。

数据范围：![img](https://www.nowcoder.com/equation?tex=0%20%5Cleq%20n%20%5Cleq%2010%5E5)，![img](https://www.nowcoder.com/equation?tex=0%20%5Cleq%20a_i%20%5Cleq%2010%5E9)，![img](https://www.nowcoder.com/equation?tex=0%20%5Cleq%20k%20%5Cleq%2010%5E9)

要求：空间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n))，时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n))

进阶：空间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(1))，时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n))

例如输入{1,2,3,4,5},2时，对应的链表结构如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211105/423483716_1636084313645/5407F55227804F31F5C5D73558596F2C)

其中蓝色部分为该链表的最后2个结点，所以返回倒数第2个结点（也即结点值为4的结点）即可，系统会打印后面所有的节点来比较。

```cpp
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 *	ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pHead, int k) {
        //先遍历链表获取链表长度【先获取长度len、后面才能遍历到指定的长度（len-k+1）】
        int len = 0;
        ListNode* p = pHead;
        while(p) {
            len++;
            p = p->next;
        }
        //根据获取的长度，要求返回倒数k的节点，即正数 n-k+1的节点
        //比如 1->2->3->4->5   k==2-->4->5
        p = pHead;//p重新指向头节点
        int cuIndex = 0;
        while(p) {
            cuIndex++;
            if(cuIndex == len - k + 1) {
                return p;//当遍历到指定的节点就是想要的结果
            }
            p = p->next;
        }
        return NULL;
    }
};
```

### NC4 判断链表中是否有环

判断给定的链表中是否有环。如果有环则返回true，否则返回false。

数据范围：链表长度 ![img](https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%2010000%20)，链表中任意节点的值满足 ![img](https://www.nowcoder.com/equation?tex=%7Cval%7C%20%3C%3D%20100000%20)

要求：空间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(1)%20)，时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n))

输入分为两部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。-1代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。

例如输入{3,2,0,-4},1时，对应的链表结构如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20220110/423483716_1641800950920/0710DD5D9C4D4B11A8FA0C06189F9E9C)

可以看出环的入口结点为从头结点开始的第1个结点（注：头结点为第0个结点），所以输出true。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        map<ListNode*, int>visitedMap;
        while(head) {
            if(visitedMap[head]) {
                return true;//如果当前节点已遍历，说明有环
            }
            visitedMap[head] = 1;//记录当前节点是否遍历锅
            head = head->next;//移动到下一个节点
        }
        return false;
    }
};
```

### NC33 合并两个排序的链表

输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。

数据范围： ![img](https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%201000)，![img](https://www.nowcoder.com/equation?tex=-1000%20%5Cle%20%E8%8A%82%E7%82%B9%E5%80%BC%20%5Cle%201000)
要求：空间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(1))，时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n))

如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}，转换过程如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634208575589/09DD8C2662B96CE14928333F055C5580)

或输入{-1,2,4},{1,3,4}时，合并后的链表为{-1,1,2,3,4,4}，所以对应的输出为{-1,1,2,3,4,4}，转换过程如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634208729766/8266E4BFEDA1BD42D8F9794EB4EA0A13)

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        //首先定义一个节点，用来存放结果
        ListNode* rsp = new ListNode(0);//用next来存放头节点
        //定义一个指针 用来移动当前节点，方便后续比较
        ListNode* currentP = rsp;//currentP用来存放比较后的节点
        while(pHead1 != NULL && pHead2 != NULL) {
            if(pHead1->val <= pHead2->val) {
               //第一步是找到头节点，当下一次循环进来的时候，currentP会移动到next
               //但是第一步的currentP->next = pHead1; 所以头节点就拿到了，就是rsp->next
               //else里面的第一步同理
                currentP->next = pHead1;
                currentP = currentP->next;//移动currentP
                pHead1 = pHead1->next;//移动pHead1
            } else {//同上
                currentP->next = pHead2;
                currentP = currentP->next;
                pHead2 = pHead2->next;
            }
        }
        if(pHead1 == NULL) {
            currentP->next = pHead2;
        } else {
            currentP->next = pHead1;
        }
        return rsp->next;
    }
};
```

### NC78 反转链表

给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。

数据范围： ![img](https://www.nowcoder.com/equation?tex=0%5Cleq%20n%5Cleq1000)

要求：空间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(1)) ，时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n)) 。

如当输入链表{1,2,3}时，

经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。

以上转换过程如下图所示：

<img src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249" alt="img" style="zoom:50%;" />

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        //解题思路：1->2->3->nullptr
        //nullptr<-1<-2<-3
        /*
        1、先定义一个前节点，初始值为nullptr
        2、定义一个curr节点，用来记录当前指针指向的当前节点
        3、在while循环中 
        	 1、获取next = curr->next
					 2、将前节点赋给curr->next----curr->next = prev【目的是让当前节点的next指向“左边”】
           3、将当前节点作为下一个节点的prev----prev = curr【移动指针，更新prev】
           将当前节点指向下一个节点----------curr = next【移动指针，更新curr】
           最终prev会从nullptr移动到头节点再移动到尾节点
        */
        ListNode* prev = nullptr;
        ListNode* curr = pHead;
        while(curr) {
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;//最终prev会从nullptr移动到头节点再移动到尾节点，此时尾节点就是翻转后的头节点
    }
};
```

### NC65 斐波那契数列

大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。

斐波那契数列是一个满足 ![img](https://www.nowcoder.com/equation?tex=fib(x)%3D%5Cleft%5C%7B%20%5Cbegin%7Barray%7D%7Brcl%7D%201%20%26%20%7Bx%3D1%2C2%7D%5C%5C%20fib(x-1)%2Bfib(x-2)%20%20%26%7Bx%3E2%7D%5C%5C%20%5Cend%7Barray%7D%20%5Cright.) 的数列

数据范围：![img](https://www.nowcoder.com/equation?tex=1%5Cleq%20n%5Cleq%2040)

要求：空间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(1))，时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n)) ，本题也有时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(logn)) 的解法

```cpp
public class Solution {
    public int Fibonacci(int n) {
        if(n == 0){
            return 0;
        }
        if(n == 1){
            return 1;
        }
        return Fibonacci(n-1) + Fibonacci(n-2);
    }
}
```


# 算法

核心参考：https://labuladong.gitee.io/algo
参考目录：https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA
学习总结：

```apl
1、先学习套路，然后在进行做题。
2、不会做的题不要一致浪费时间，leecode上有解题思路，可以仔细学习消化。如果始终无法理解，也不要浪费时间，先放一放，继续后面的任务，间隔一小段时间后再来看，可以继续学习相关内容，然后在来看不会的题。
3、对自己掌握的内容一定要做好文档，后面还可以录制视频「前提是文档准备得足够充分」
4、通常做过的题目，尤其是比较难的题目，隔一段时间后还要在做一次，记得写下解题的思路
```

## 1、前缀和

参考文章：https://mp.weixin.qq.com/s/r-6Yfp2qn_x8nKJMVirdyQ

```apl
核心思想：
前缀和的意思就是：一个数列的总和
我们在做数组类求和的算法题时，可以对已知数组求出数组的总和，即这里的前缀和
比如数组  S5={a1+a2+a3+a4+a5};
由于 S5 = a1+a2+a3+a4+a5;  S2 = a1+a2;
由于 S5-S2 = a3+a4+a5 注意！这里的a3~a5就是一个连续的子数组
我们可以得出这样的结论。  Sx - Sy = a(y+1)+...+ax;(x>y),比如上面的S5-S2的例子
利用上面的规律我们可以对很多类似的数组题进行求解
```

了解以上思想，对下列类型算法题的解答将会变得更容易理解，其实也并不简单。关键还是理解+实践
必须在牛客网or力扣上实践，否则无法检验。

注意：关于下列算法的详细需求，自行移步到leecode查看，思路可以参考顶部的 前缀和文章

### 1、leecode 724 寻找数组的中心下标（简单）

给你一个整数数组 nums ，请计算数组的 中心下标 。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。

 示例 1：

输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
示例 2：

输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
示例 3：

输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。

```c++
#include<iostream>
#include<vector>
using namespace std;

int pivotIndex(vector<int>& nums) {
    //利用前缀和思想解决
    //先计算数组的总和
    int presum = 0;
    for(int i = 0; i < nums.size(); i++){
        presum += nums[i];
    }

    //然后找出中心索引-> leftSum + nums[centerIndex] + rightSum = presum
    //leftSum = (presum - nums[centerIndex])/2
    int leftSum = 0;
    for(int i = 0; i<nums.size(); i++){
        if(leftSum == (presum-nums[i])/2){
            return i;
        }
        leftSum += nums[i];
    }
    return -1;
}

int main(){
    vector<int>intArr;
    intArr.push_back(1);
    intArr.push_back(2);
    intArr.push_back(3);
    intArr.push_back(4);
    intArr.push_back(5);
    intArr.push_back(5);
    intArr.push_back(5);
    cout <<pivotIndex(intArr)<<endl;
    return 0;
}
```

### 2、leecode 1 两数之和（简单）

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]

```c++
#include<iostream>
#include<vector>
using namespace std;

vector<int> twoSum(vector<int>& nums, int target) {
        vector<int>targetNums;
        for(int i = 0; i < nums.size(); i ++){
            for(int j = i+1; j < nums.size(); j ++){
                if(nums[i] + nums[j] == target){
                    targetNums.push_back(i);
                    targetNums.push_back(j);
                    return targetNums;
                }
            }
        }
        return targetNums;
    }

int main(){
    vector<int>intArr;
    intArr.push_back(1);
    intArr.push_back(2);
    intArr.push_back(3);
    vector<int>result = twoSum(intArr, 5);
    cout <<"["<<result[0]<<"],["<<result[1]<<"]"<<endl;
    return 0;
}

```

### 3、[lecode 1588. 所有奇数长度子数组的和](https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/)

给你一个正整数数组 `arr` ，请你计算所有可能的奇数长度子数组的和。
**子数组** 定义为原数组中的一个连续子序列。
请你返回 `arr` 中 **所有奇数长度子数组的和** 。

**示例 1：**

```
输入：arr = [1,4,2,5,3]
输出：58
解释：所有奇数长度子数组和它们的和为：
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
```

**示例 2：**

```
输入：arr = [1,2]
输出：3
解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。
```

**示例 3：**

```
输入：arr = [10,11,12]
输出：66
```

 

**提示：**

- `1 <= arr.length <= 100`

- `1 <= arr[i] <= 1000`

  ```c++
  #include<iostream>
  #include<vector>
  using namespace std;
  
  int sumOddLengthSubarrays(vector<int>& arr) {
      int result = 0;//注意 一定要初始化，不然结果会错误	
      vector<int>presum;
      presum.push_back(0);
      for (int i = 0; i < arr.size(); i++) {
          presum.push_back(presum[i]+arr[i]);
      }
      for (int i = 0; i < presum.size(); i++) {//注意 这里用的是presum.size() 而不是 arr.size()
          for (int j = i+1; j < presum.size(); j++) {
              if ((j-i)%2 != 0) {
                  result += presum[j] - presum[i];
              }
          }
      }
      return result;
  }
  
  int main(){
      vector<int>arr;
      arr.push_back(1);
      arr.push_back(4);
      arr.push_back(2);
      arr.push_back(5);
      arr.push_back(3);
      cout << sumOddLengthSubarrays(arr) << endl;
  }
  
  ```


### 3、leecode 560 和为K的子数组（中等）

给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。

示例 1：

输入：nums = [1,1,1], k = 2
输出：2
示例 2：

输入：nums = [1,2,3], k = 3
输出：2

暴力解法

```c++
#include<iostream>
#include<vector>
using namespace std;

int sumKSubArray(vector<int>&nums, int k){//暴力解法【时间复杂度 O(n)方】
    int count = 0;
    int subSum = 0;
    for (int i = 0; i < nums.size(); i++) {
        for (int j = i; j < nums.size(); j++) {
            subSum += nums[j];
            if (subSum == k) {
                count++;
            }
        }
        subSum = 0;
    }
    return count;
}

int main(){
    vector<int>intArr;
    intArr.push_back(1);
    intArr.push_back(-1);
    intArr.push_back(0);
    cout <<sumKSubArray(intArr, 0)<<endl;
    return 0;
}
```

hash+前缀和 解法 这个题并没有完全搞懂！

```c++
#include<iostream>
#include<vector>
#include<map>
using namespace std;

int sumKSubArray(vector<int>&nums, int k){
    int count = 0;
    map<int, int> mapPresum;
    mapPresum[0] = 1;//这里的值是为了覆盖k=0的情况
    int presum = 0;
    for(int i = 0; i < nums.size(); i ++){
        presum += nums[i];
        if (mapPresum[presum-k]) {//这里也不是很好理解
            count += mapPresum[presum -k];//这里也不是很好理解
        }
        if (mapPresum[presum]) {
            mapPresum[presum] += 1;//注意这里是 += 1;
        } else {
            mapPresum[presum] = 1;
        }
    }
    //本题和 leecode 统计优美子数组 题目很像，建议一同处理
    return count;
}

int main(){
    vector<int>intArr;
    intArr.push_back(1);
    intArr.push_back(-1);
    intArr.push_back(0);
    cout <<sumKSubArray(intArr, 0)<<endl;
    return 0;
}

```

### 4、[1893. 检查是否区域内所有整数都被覆盖](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/)

给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。

如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。

已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti <= x <= endi ，那么我们称整数x 被覆盖了。

 示例 1：

输入：ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5
输出：true
解释：2 到 5 的每个整数都被覆盖了：
- 2 被第一个区间覆盖。
- 3 和 4 被第二个区间覆盖。
- 5 被第三个区间覆盖。
示例 2：

输入：ranges = [[1,10],[10,20]], left = 21, right = 21
输出：false
解释：21 没有被任何一个区间覆盖。

```c++
这道题做出来了，但是第二次做的时候没做出来，后面再做！
```

### 5、[lecode 1310. 子数组异或查询](https://leetcode-cn.com/problems/xor-queries-of-a-subarray/)

暴力解法->超出了时间限制
这里我的思路是：先对queries数组遍历，取出它的每一个元素，然后在根据元素的第一位和第二位进行遍历arr中的元素，对其进行异或运算。

```c++
vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
    vector<int>xorVec;
    for(int i = 0; i< queries.size(); i++){
        vector<int>subQuery = queries[i];
        int xora = 0;
        for(int j = subQuery[0]; j <= subQuery[1]; j++){
            if (subQuery[0] == subQuery[1]) {//根据题目要求当开始位置和结束为止相同，则返回
                xorVec.push_back(arr[subQuery[0]]);
                break;
            }
            if (j == subQuery[0]) {//将第一个元素放入xora中，等待异或运算
                xora = arr[subQuery[0]];
            } else {//异或运算
                xora ^= arr[j];
            }
            if(j == subQuery[1]){//当计算到末尾结束后将结果放到结果数组中
                xorVec.push_back(xora);
            }
        }
    }
    return xorVec;
}

下面是参考网上的答案实现的代码，时间复杂度一致，但更加简洁
vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
      //首先床蓟爱你一个整型数组，用于返回结果，它的长度==queries的长度
      vector<int>resultVec;
      //遍历queries数组
      for(int i = 0; i < queries.size(); i++){
          //获取当前的queries子数组
          vector<int>subQue = queries[i];
          int r = 0;//用于存放当前queries子数组范围内的异或和
          //遍历queries子数组的范围，求 异或和
          for(int j = subQue[0]; j <= subQue[1]; j++){
            //当 subQue[0]==subQue[1]时，r = 0 ^ arr[j]-->==arr[j]
            //因为 0^任何数 == 任何数
              r = r ^ arr[j];
          }
          resultVec.push_back(r);
      }
      return resultVec;
  }
```

更优解：前缀和思想
这里的前缀和，实际上是前n项做异或后的结果，所以可以得到：xors[i]=arr[0]⊕…⊕*arr*[*i*−1]
对于查询[left,right](left<=right),用Q(left,right)表示该查询的结果。
当left=0时，Q(left,right) = xors[right+1];
当left>0时，Q(left,right)的计算如下：
Q(left,right) = arr[left]⊕...⊕arr[right]
//下一这行的等式是凑出来的因为a⊕a⊕b=b，这一行的左边两个arr[0]⊕...⊕[left-1]异或就得0
= (arr[0]⊕...⊕[left-1])⊕(arr[0]⊕...⊕arr[left-1])⊕(arr[left]⊕...⊕arr[right])
//下一行的右边就是上一行的右边两个大项异或的合并
= (arr[0]⊕...⊕[left-1])⊕(arr[0]⊕...⊕arr[right])
//由于xors[i]=arr[0]⊕...⊕arr[i−1],于是xors[left]=arr[0]⊕...⊕arr[left−1]
//于是xors[right+1]=arr[0]⊕...⊕arr[right]
//于是有
= xors[left]⊕xors[right+1]
所以，我们先求出前缀和，然后根据Q(left,right) = arr[left]⊕...⊕arr[right]=xors[left]⊕xors[right+1]，求出想要的结果即可

```c++
vector<int> xorQueries2(vector<int>& arr, vector<vector<int>>& queries) {
    size_t n = arr.size();//获取arr长度
    vector<int> xors(n + 1);//注意 这里一定要提前指定大小，开辟空间，否则下面会crash
    //构造前缀和，这里是前n项做异或结果的数组
    for (int i = 0; i < n; i++) {
        xors[i + 1] = xors[i] ^ arr[i];
    }
    size_t m = queries.size();
    vector<int> ans(m);//注意 这里一定要提前指定大小，开辟空间，否则下面会crash
    for (int i = 0; i < m; i++) {
        //这里其实就是利用前缀公司求出来的结果，所以这行代码很关键，它贯穿了全部代码的来龙去脉
        ans[i] = xors[queries[i][0]] ^ xors[queries[i][1] + 1];
    }
    return ans;
}
```

### 7、[1738. 找出第 K 大的异或坐标值](https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/)

这个题先放一放，感觉比较难。leecode上有解题思路，后面再做「2022-2-3-pm」

### 8、[1177. 构建回文串检测](https://leetcode-cn.com/problems/can-make-palindrome-from-substring/)

这个题先放一放，感觉比较难。leecode上有解题思路，后面再做「2022-2-3-21:19」

### 4、leecode 1248 统计优美子数组（中等）

```c++
这个题和 3、leecode560 和为K的子数组 很像
本题用「滑动窗口」、「前缀和+差分」也能做，由于目前还未学习，所以本例只讲解前缀和的思路

int numberOfSubarrays(vector<int>& nums, int k) {
        int count = 0;
        //先统计奇数个数，相当于前缀和
        int jiNum = 0;
        map<int, int>mapJi;
        mapJi[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            jiNum += nums[i] & 1;  //xxxx & 0001--> 如果是 奇数&1==1，否则==0
            if (mapJi[jiNum - k]) {//注意这里的 key=jiNum-k
                count += mapJi[jiNum -k];//注意这里的 key=jiNum-k
            }
            if (mapJi[jiNum]) {
                mapJi[jiNum] += 1;//注意 这里是 +=1;
            } else {
                mapJi[jiNum] = 1;
            }
        }
    
    return count;
}

```

下面两题有时间再做

### 9、leecode 974 和可被K整除的子数组（中等）

### 10、leecode 523 连续的子数组和（中等）

### 11、leecode 930 和相同的二元子数组（中等）

本题和  leetcode 560. 和为K的子数组 类似

---



## 2、单调栈

参考文章：https://mp.weixin.qq.com/s/Y2QZZ-coEYZ6ItDRyrdwVw

```apl
核心思想
```

### 1、[剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

示例 1：

输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
示例 2：

输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]

```c++
首先解释一下题目意思：
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]

说明：
null：定义队列，输入为[],不需要入参，不需要返回值，所以输出null
null：入队操作，不需要返回值，将元素1入队，返回null
null：入队操作，不需要返回值，将元素2入队，返回null
2:max_value，返回最大值，输入为[]，不需要入参，所以返回2
1:pop_front，出队操作，1先入队所以先出队1
2:max_value,返回最大值，输入为[]，不需要入参，所以返回2「？？？获取最大值，并不意味着获取的值要出队，所以这里还会返回2」

解题思路：构造两个队列，一个单项队列q；一个双向队列d，单项队列无条件的入队、出队、双向队列入队时要保证左边元素始终是最大的，出队时要和单项队列一起出队。
max_value，如果队列为空就返回-1，否则返回双向队列左边的元素
push_back，在双向队列入队时，从右边入队，要保证入队元素比右边的元素大，如果右边的元素比入队元素小，则将右边元素出队，直到满足条件。这样就能保证双向队列的最左边是最大元素
pop_front，出队时，如果单项队列为空就返回-1，如果两个队列左边元素相等就都出队，否则只队q出队
  
#include <queue>
#include <deque>
class MaxQueue {
    queue<int>q;//单向队列
    deque<int>d;//双向队列
public:
    MaxQueue(){}
    
    int max_value(){
        if (d.empty()) {
            return -1;
        }
        return d.front();//返回最左边的元素？
    }
    
    void push_back(int value) {
        //循环 队列不能为空 且 队列右边的第一个元素 < value
        while (!d.empty() && d.back() < value) {
            d.pop_back();//将右边的第一个元素出队
        }
        d.push_back(value);//入队
        q.push(value);//单向队列入队
    }
    
    int pop_front() {
        if (q.empty()) {
            return -1;
        }
        int ans = q.front();//q出队左边
        if (ans == d.front()) {
            d.pop_front();//如果d左边第一个元素==q左边出队的元素，d左边也出队
        }
        q.pop();//因为q是单向队列 所以直接pop就出队了
        return ans;
    }
};  

```



---

## 3、双指针

参考文章：https://mp.weixin.qq.com/s/C4ZFwyJThBJdyqbNo87isQ

```apl
核心思想
```

---

## 4、BFS 

参考文章：https://mp.weixin.qq.com/s/WH_XGm1-w5882PnenymZ7g

```apl
核心思想
```

---

## 5、DFS 

参考文章：https://www.bilibili.com/video/BV1P5411N7Xc

```apl
核心思想
```

---

## 6、滑动窗口

参考文章：https://www.cnblogs.com/huansky/p/13488234.html

```apl
核心思想
```

---

## 7、并查集

参考文章：https://segmentfault.com/a/1190000004023326

```apl
核心思想
```

---



## redo笔记

### 1、前缀和

[1893. 检查是否区域内所有整数都被覆盖](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/)


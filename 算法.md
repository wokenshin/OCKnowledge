# 算法

核心参考：https://labuladong.gitee.io/algo
参考目录：https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA
学习总结：

```apl
1、先学习套路，然后在进行做题。
2、不会做的题不要一致浪费时间，leecode上有解题思路，可以仔细学习消化。如果始终无法理解，也不要浪费时间，先放一放，继续后面的任务，间隔一小段时间后再来看，可以继续学习相关内容，然后在来看不会的题。
3、对自己掌握的内容一定要做好文档，后面还可以录制视频「前提是文档准备得足够充分」
4、通常做过的题目，尤其是比较难的题目，隔一段时间后还要在做一次，记得写下解题的思路
```

## 1、前缀和

参考文章：https://mp.weixin.qq.com/s/r-6Yfp2qn_x8nKJMVirdyQ

```apl
核心思想：
前缀和的意思就是：一个数列的总和
我们在做数组类求和的算法题时，可以对已知数组求出数组的总和，即这里的前缀和
比如数组  S5={a1+a2+a3+a4+a5};
由于 S5 = a1+a2+a3+a4+a5;  S2 = a1+a2;
由于 S5-S2 = a3+a4+a5 注意！这里的a3~a5就是一个连续的子数组
我们可以得出这样的结论。  Sx - Sy = a(y+1)+...+ax;(x>y),比如上面的S5-S2的例子
利用上面的规律我们可以对很多类似的数组题进行求解
```

了解以上思想，对下列类型算法题的解答将会变得更容易理解，其实也并不简单。关键还是理解+实践
必须在牛客网or力扣上实践，否则无法检验。

注意：关于下列算法的详细需求，自行移步到leecode查看，思路可以参考顶部的 前缀和文章

### 1、leecode 724 寻找数组的中心下标（简单）

给你一个整数数组 nums ，请计算数组的 中心下标 。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。

 示例 1：

输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
示例 2：

输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
示例 3：

输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。

```c++
#include<iostream>
#include<vector>
using namespace std;

int pivotIndex(vector<int>& nums) {
    //利用前缀和思想解决
    //先计算数组的总和
    int presum = 0;
    for(int i = 0; i < nums.size(); i++){
        presum += nums[i];
    }

    //然后找出中心索引-> leftSum + nums[centerIndex] + rightSum = presum
    //leftSum = (presum - nums[centerIndex])/2
    int leftSum = 0;
    for(int i = 0; i<nums.size(); i++){
        if(leftSum == (presum-nums[i])/2){
            return i;
        }
        leftSum += nums[i];
    }
    return -1;
}

int main(){
    vector<int>intArr;
    intArr.push_back(1);
    intArr.push_back(2);
    intArr.push_back(3);
    intArr.push_back(4);
    intArr.push_back(5);
    intArr.push_back(5);
    intArr.push_back(5);
    cout <<pivotIndex(intArr)<<endl;
    return 0;
}
```

### 2、leecode 1 两数之和（简单）

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]

```c++
#include<iostream>
#include<vector>
using namespace std;

vector<int> twoSum(vector<int>& nums, int target) {
        vector<int>targetNums;
        for(int i = 0; i < nums.size(); i ++){
            for(int j = i+1; j < nums.size(); j ++){
                if(nums[i] + nums[j] == target){
                    targetNums.push_back(i);
                    targetNums.push_back(j);
                    return targetNums;
                }
            }
        }
        return targetNums;
    }

int main(){
    vector<int>intArr;
    intArr.push_back(1);
    intArr.push_back(2);
    intArr.push_back(3);
    vector<int>result = twoSum(intArr, 5);
    cout <<"["<<result[0]<<"],["<<result[1]<<"]"<<endl;
    return 0;
}

```

### 3、[lecode 1588. 所有奇数长度子数组的和](https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/)

给你一个正整数数组 `arr` ，请你计算所有可能的奇数长度子数组的和。
**子数组** 定义为原数组中的一个连续子序列。
请你返回 `arr` 中 **所有奇数长度子数组的和** 。

**示例 1：**

```
输入：arr = [1,4,2,5,3]
输出：58
解释：所有奇数长度子数组和它们的和为：
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
```

**示例 2：**

```
输入：arr = [1,2]
输出：3
解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。
```

**示例 3：**

```
输入：arr = [10,11,12]
输出：66
```

 

**提示：**

- `1 <= arr.length <= 100`

- `1 <= arr[i] <= 1000`

  ```c++
  #include<iostream>
  #include<vector>
  using namespace std;
  
  int sumOddLengthSubarrays(vector<int>& arr) {
      int result = 0;//注意 一定要初始化，不然结果会错误	
      vector<int>presum;
      presum.push_back(0);
      for (int i = 0; i < arr.size(); i++) {
          presum.push_back(presum[i]+arr[i]);
      }
      for (int i = 0; i < presum.size(); i++) {//注意 这里用的是presum.size() 而不是 arr.size()
          for (int j = i+1; j < presum.size(); j++) {
              if ((j-i)%2 != 0) {
                  result += presum[j] - presum[i];
              }
          }
      }
      return result;
  }
  
  int main(){
      vector<int>arr;
      arr.push_back(1);
      arr.push_back(4);
      arr.push_back(2);
      arr.push_back(5);
      arr.push_back(3);
      cout << sumOddLengthSubarrays(arr) << endl;
  }
  
  ```


### 3、leecode 560 和为K的子数组「中等」

给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。

示例 1：

输入：nums = [1,1,1], k = 2
输出：2
示例 2：

输入：nums = [1,2,3], k = 3
输出：2

暴力解法

```c++
#include<iostream>
#include<vector>
using namespace std;

int sumKSubArray(vector<int>&nums, int k){//暴力解法【时间复杂度 O(n)方】
    int count = 0;
    int subSum = 0;
    for (int i = 0; i < nums.size(); i++) {
        for (int j = i; j < nums.size(); j++) {
            subSum += nums[j];
            if (subSum == k) {
                count++;
            }
        }
        subSum = 0;
    }
    return count;
}

int main(){
    vector<int>intArr;
    intArr.push_back(1);
    intArr.push_back(-1);
    intArr.push_back(0);
    cout <<sumKSubArray(intArr, 0)<<endl;
    return 0;
}
```

hash+前缀和 解法 这个题并没有完全搞懂！

```c++
#include<iostream>
#include<vector>
#include<map>
using namespace std;

int sumKSubArray(vector<int>&nums, int k){
    int count = 0;
    map<int, int> mapPresum;
    mapPresum[0] = 1;//这里的值是为了覆盖k=0的情况
    int presum = 0;
    for(int i = 0; i < nums.size(); i ++){
        presum += nums[i];
        if (mapPresum[presum-k]) {//这里也不是很好理解
            count += mapPresum[presum -k];//这里也不是很好理解
        }
        if (mapPresum[presum]) {
            mapPresum[presum] += 1;//注意这里是 += 1;
        } else {
            mapPresum[presum] = 1;
        }
    }
    //本题和 leecode 统计优美子数组 题目很像，建议一同处理
    return count;
}

int main(){
    vector<int>intArr;
    intArr.push_back(1);
    intArr.push_back(-1);
    intArr.push_back(0);
    cout <<sumKSubArray(intArr, 0)<<endl;
    return 0;
}

```

### 4、[1893. 检查是否区域内所有整数都被覆盖](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/)「简单」

给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。

如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。

已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti <= x <= endi ，那么我们称整数x 被覆盖了。

 示例 1：

输入：ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5
输出：true
解释：2 到 5 的每个整数都被覆盖了：
- 2 被第一个区间覆盖。
- 3 和 4 被第二个区间覆盖。
- 5 被第三个区间覆盖。
示例 2：

输入：ranges = [[1,10],[10,20]], left = 21, right = 21
输出：false
解释：21 没有被任何一个区间覆盖。

```c++
这道题做出来了，但是第二次做的时候没做出来，后面再做！
```

### 5、[lecode 1310. 子数组异或查询](https://leetcode-cn.com/problems/xor-queries-of-a-subarray/)「中等」

暴力解法->超出了时间限制
这里我的思路是：先对queries数组遍历，取出它的每一个元素，然后在根据元素的第一位和第二位进行遍历arr中的元素，对其进行异或运算。

```c++
vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
    vector<int>xorVec;
    for(int i = 0; i< queries.size(); i++){
        vector<int>subQuery = queries[i];
        int xora = 0;
        for(int j = subQuery[0]; j <= subQuery[1]; j++){
            if (subQuery[0] == subQuery[1]) {//根据题目要求当开始位置和结束为止相同，则返回
                xorVec.push_back(arr[subQuery[0]]);
                break;
            }
            if (j == subQuery[0]) {//将第一个元素放入xora中，等待异或运算
                xora = arr[subQuery[0]];
            } else {//异或运算
                xora ^= arr[j];
            }
            if(j == subQuery[1]){//当计算到末尾结束后将结果放到结果数组中
                xorVec.push_back(xora);
            }
        }
    }
    return xorVec;
}

下面是参考网上的答案实现的代码，时间复杂度一致，但更加简洁
vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
      //首先床蓟爱你一个整型数组，用于返回结果，它的长度==queries的长度
      vector<int>resultVec;
      //遍历queries数组
      for(int i = 0; i < queries.size(); i++){
          //获取当前的queries子数组
          vector<int>subQue = queries[i];
          int r = 0;//用于存放当前queries子数组范围内的异或和
          //遍历queries子数组的范围，求 异或和
          for(int j = subQue[0]; j <= subQue[1]; j++){
            //当 subQue[0]==subQue[1]时，r = 0 ^ arr[j]-->==arr[j]
            //因为 0^任何数 == 任何数
              r = r ^ arr[j];
          }
          resultVec.push_back(r);
      }
      return resultVec;
  }
```

更优解：前缀和思想
这里的前缀和，实际上是前n项做异或后的结果，所以可以得到：xors[i]=arr[0]⊕…⊕*arr*[*i*−1]
对于查询[left,right](left<=right),用Q(left,right)表示该查询的结果。
当left=0时，Q(left,right) = xors[right+1];
当left>0时，Q(left,right)的计算如下：
Q(left,right) = arr[left]⊕...⊕arr[right]
//下一这行的等式是凑出来的因为a⊕a⊕b=b，这一行的左边两个arr[0]⊕...⊕[left-1]异或就得0
= (arr[0]⊕...⊕[left-1])⊕(arr[0]⊕...⊕arr[left-1])⊕(arr[left]⊕...⊕arr[right])
//下一行的右边就是上一行的右边两个大项异或的合并
= (arr[0]⊕...⊕[left-1])⊕(arr[0]⊕...⊕arr[right])
//由于xors[i]=arr[0]⊕...⊕arr[i−1],于是xors[left]=arr[0]⊕...⊕arr[left−1]
//于是xors[right+1]=arr[0]⊕...⊕arr[right]
//于是有
= xors[left]⊕xors[right+1]
所以，我们先求出前缀和，然后根据Q(left,right) = arr[left]⊕...⊕arr[right]=xors[left]⊕xors[right+1]，求出想要的结果即可

```c++
vector<int> xorQueries2(vector<int>& arr, vector<vector<int>>& queries) {
    size_t n = arr.size();//获取arr长度
    vector<int> xors(n + 1);//注意 这里一定要提前指定大小，开辟空间，否则下面会crash
    //构造前缀和，这里是前n项做异或结果的数组
    for (int i = 0; i < n; i++) {
        xors[i + 1] = xors[i] ^ arr[i];
    }
    size_t m = queries.size();
    vector<int> ans(m);//注意 这里一定要提前指定大小，开辟空间，否则下面会crash
    for (int i = 0; i < m; i++) {
        //这里其实就是利用前缀公司求出来的结果，所以这行代码很关键，它贯穿了全部代码的来龙去脉
        ans[i] = xors[queries[i][0]] ^ xors[queries[i][1] + 1];
    }
    return ans;
}
```

### 7、[1738. 找出第 K 大的异或坐标值](https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/)

这个题先放一放，感觉比较难。leecode上有解题思路，后面再做「2022-2-3-pm」

### 8、[1177. 构建回文串检测](https://leetcode-cn.com/problems/can-make-palindrome-from-substring/)

这个题先放一放，感觉比较难。leecode上有解题思路，后面再做「2022-2-3-21:19」

### 4、leecode 1248 统计优美子数组「中等」

```c++
这个题和 3、leecode560 和为K的子数组 很像
本题用「滑动窗口」、「前缀和+差分」也能做，由于目前还未学习，所以本例只讲解前缀和的思路

int numberOfSubarrays(vector<int>& nums, int k) {
        int count = 0;
        //先统计奇数个数，相当于前缀和
        int jiNum = 0;
        map<int, int>mapJi;
        mapJi[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            jiNum += nums[i] & 1;  //xxxx & 0001--> 如果是 奇数&1==1，否则==0
            if (mapJi[jiNum - k]) {//注意这里的 key=jiNum-k
                count += mapJi[jiNum -k];//注意这里的 key=jiNum-k
            }
            if (mapJi[jiNum]) {
                mapJi[jiNum] += 1;//注意 这里是 +=1;
            } else {
                mapJi[jiNum] = 1;
            }
        }
    
    return count;
}

```

下面两题有时间再做

### 9、leecode 974 和可被K整除的子数组「中等」

### 10、leecode 523 连续的子数组和「中等」

### 11、leecode 930 和相同的二元子数组「中等」

本题和  leetcode 560. 和为K的子数组 类似

---



## 2、单调栈

参考文章：https://mp.weixin.qq.com/s/Y2QZZ-coEYZ6ItDRyrdwVw
参考文章：https://labuladong.gitee.io/algo/2/20/51/

```apl
核心思想
栈（stack）是很简单的一种数据结构，先进后出的逻辑顺序，符合某些问题的特点，比如说函数调用栈。
单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）

```

### 1、[剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)「中等」

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

示例 1：

输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
示例 2：

输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]

```c++
首先解释一下题目意思：
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]

说明：
null：定义队列，输入为[],不需要入参，不需要返回值，所以输出null
null：入队操作，不需要返回值，将元素1入队，返回null
null：入队操作，不需要返回值，将元素2入队，返回null
2:max_value，返回最大值，输入为[]，不需要入参，所以返回2
1:pop_front，出队操作，1先入队所以先出队1
2:max_value,返回最大值，输入为[]，不需要入参，所以返回2「？？？获取最大值，并不意味着获取的值要出队，所以这里还会返回2」

大致思路：双向队列左边是种放最大的元素，入队的时候从右边入队，如果入队元素比右边元素大，右边元素就要出队。这样每次获取最大元素的时候，从双向队列左边获取即可。
  
详细思路：构造两个队列，一个单项队列q；一个双向队列d，单项队列无条件的入队、出队、双向队列入队时要保证左边元素始终是最大的，出队时要和单项队列一起出队。
max_value，如果队列为空就返回-1，否则返回双向队列左边的元素
push_back，在双向队列入队时，从右边入队，要保证入队元素比右边的元素大，如果右边的元素比入队元素小，则将右边元素出队，直到满足条件。这样就能保证双向队列的最左边是最大元素
pop_front，出队时，如果单项队列为空就返回-1，如果两个队列左边元素相等就都出队，否则只队q出队
  
#include <queue>
#include <deque>
class MaxQueue {
    queue<int>q;//单向队列
    deque<int>d;//双向队列
public:
    MaxQueue(){}
    
    int max_value(){
        if (d.empty()) {
            return -1;
        }
        return d.front();//返回最左边的元素？
    }
    
    void push_back(int value) {
        //循环 队列不能为空 且 队列右边的第一个元素 < value
        while (!d.empty() && d.back() < value) {
            d.pop_back();//将右边的第一个元素出队
        }
        d.push_back(value);//入队
        q.push(value);//单向队列入队
    }
    
    int pop_front() {
        if (q.empty()) {
            return -1;
        }
        int ans = q.front();//q出队左边
        if (ans == d.front()) {
            d.pop_front();//如果d左边第一个元素==q左边出队的元素，d左边也出队
        }
        q.pop();//因为q是单向队列 所以直接pop就出队了
        return ans;
    }
};  

```

### 2、[剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)「困难」

这道题的难度是[困难]，暂时不做了。目前只做[简单]和[中等]

### 3、[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)「简单」

注意！这里用的数据结构是栈，而不是队列
思路：用一个数据栈来放默认操作的一些数据，用一个辅助栈来存放栈顶始终都是最小值的数据

```c++
#include<stack>
using namespace std;//注意这里的命名空间，否则下面的stack不能直接声明

class MinStack {
    stack<int>x_stack;//这是数据栈，即原本的数据处理栈
    stack<int>min_stack;//这是一个辅助栈，栈顶为最小值
    public:
    MinStack(){
        min_stack.push(INT_MAX);//为什么要放一个最大值到辅助栈中？
        //因为第一次push的时候 min_stack.top() 要有值，否则会crash，当然也可以自己做判断，这里就不用push了
    }
    
    void pop(){
        x_stack.pop();
        min_stack.pop();
    }
    
    void push(int x){
        x_stack.push(x);
        min_stack.push(min(min_stack.top(), x));//push的原属要和原站定元素比较，叫最小值入栈
        //当top<x时，岂不是会遇到重复的多个元素被入栈？是的，因为当重复的时候，说明x_stack中也有重复的最小值
    }
    
    int getMin(){
        return min_stack.top();
    }
    
    int top(){
        return x_stack.top();
    }
};
```

### 4、[496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)「简单」

nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。
给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。
对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。

返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。

示例 1：

输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：

- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。

```c++
思路：题目说nums1是nums2的子集，并不是说nums1是nums2的子数组，也弄错了!
意思是我们要遍历nums1中的每一个元素，并且找到它在nums2中对应的位置，然后找出它的下一个更大的元素作为返回值，如果不存在则返回-1

下面是我的思路后的解题代码，缺点是三层嵌套，通常不会出现完全遍历的情况，因为内循环下标不是起始点
由于是简单题，后面在考虑更优解「2022-2-4」
vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        vector<int>result;
        for(int i = 0; i < nums1.size(); i++){
            int nums1E = nums1[i];
            for(int j = 0; j < nums2.size(); j++){
                if(nums1E == nums2[j]){
                    if (j+1 < nums2.size()) {//存在下一个元素
                        for(int k = j+1; k < nums2.size(); k++){
                            if(nums2[k] > nums1E){//找到下一个更大元素
                                result.push_back(nums2[k]);
                                break;
                            }
                            if(nums2.size() == k+1){//没有找到
                                result.push_back(-1);
                            }
                        }
                    } else {//不存在下一个元素
                        result.push_back(-1);//不存在下一个更大元素
                    }
                }
            }
        }
        return result;
}
```

更优解 from:https://labuladong.gitee.io/algo/2/20/51/

```c++
vector<int> nextGreaterElement(vector<int>& nums) {
    vector<int> res(nums.size()); // 存放答案的数组
    stack<int> s;
    // 倒着往栈里放
    for (int i = nums.size() - 1; i >= 0; i--) {
        // 判定个子高矮
        while (!s.empty() && s.top() <= nums[i]) {
            // 矮个起开，反正也被挡着了。。。
            s.pop();
        }
        // nums[i] 身后的 next great number
        res[i] = s.empty() ? -1 : s.top();
        s.push(nums[i]);
    }
    return res;
}
```



### 5、[1475. 商品折扣后的最终价格](https://leetcode-cn.com/problems/final-prices-with-a-special-discount-in-a-shop/)「简单」

给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。

商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j > i 且 prices[j] <= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。
请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。

示例 1：

输入：prices = [8,4,6,2,3]
输出：[4,2,4,2,3]
解释：
商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。
商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。
商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。
商品 3 和 4 都没有折扣。

```c++
思路：题目的大概意思是数组中商品的折扣价格=它自身价格与“下一件”价格<=当前商品价格做的差
所以折扣的价格最低可以为0，如果不存在下一件商品或者没有价格比当前商品更低或相等的商品，则当前商品无折扣
由于是简单题，这里暂时不处理更优解
vector<int> finalPrices(vector<int>& prices) {
    vector<int>resultVec;
    for(int i = 0; i < prices.size(); i++){
        int cuPrice = prices[i];
        if (i == prices.size()-1) {
            resultVec.push_back(cuPrice);
            break;
        }
        for(int j = i+1; j< prices.size(); j++){
            if(cuPrice >= prices[j]){//注意这里是 >= 折扣后的价格最低可以为0
                resultVec.push_back(cuPrice-prices[j]);
                break;
            }
            if(j == prices.size()-1){//判断到最后一个元素
                resultVec.push_back(cuPrice);//无折扣
                break;
            }
        }
    }
    return resultVec;
}
```

### 6、[739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)「中等」

```c++
由于for循环嵌套的原因，下面的解法超出时间复杂度限制了
vector<int> dailyTemperatures(vector<int>& temperatures) {
      vector<int>resultVec;
      for(int i = 0; i <temperatures.size(); i++){
          int cuT = temperatures[i];
          if(i == temperatures.size()-1){
              resultVec.push_back(0);
              break;
          }
          for(int j = i+1; j < temperatures.size(); j++){
              if(cuT < temperatures[j]){
                  resultVec.push_back(j-i);
                  break;
              }
              if(j == temperatures.size()-1){
                  resultVec.push_back(0);
                  break;
              }
          }
      }
      return resultVec;
}
```

更优解：from：https://labuladong.gitee.io/algo/2/20/51/

```c++
//下面的解法是从labuladong资源找到的，这里逆向遍历不是很好理解
#include<vector>
#include <stack>
#include<iostream>
using namespace std;
//两个巧妙的地方1:栈里放索引 2:逆序遍历，因为这样出栈时的顺序就和数组一致了
vector<int>getNextGreater(vector<int>&T){
    vector<int>res(T.size());
    stack<int>s;
    for (int i = T.size()-1; i>=0; i--) {//注意！这里是反向遍历
        while (!s.empty() && T[s.top()] <= T[i]) {
            s.pop();
        }
        res[i] = s.empty()?0:(s.top()-i);//得到索引间距
        s.push(i);//将索引入栈，而不是元素
    }
    return res;
}

//正向遍历求解，解法来自leecode 
//参考：https://leetcode-cn.com/problems/daily-temperatures/solution/dong-hua-yan-shi-dan-diao-zhan-739mei-ri-iita/
//需要注意的是while中res赋值的这行代码
vector<int> dailyTemperatures(vector<int>& temperatures) {
    vector<int>res(temperatures.size());
    stack<int>s;
    for (int i = 0; i < temperatures.size(); i++) {
        while(!s.empty() && temperatures[i] > temperatures[s.top()]){
            int prevIndex = s.top();//取出栈中保存的索引
            res[prevIndex] = i-prevIndex;//注意这一行！给对应索引下的元素求值
            s.pop();
        }
        s.push(i);
    }
    return res;
}
```

### 7、[1504. 统计全 1 子矩形](https://leetcode-cn.com/problems/count-submatrices-with-all-ones/)「中等」

明白题目的意思，但是做不出来，leecode上有解题思路，目前看不懂，暂时先跳过吧。2022-02-05

### 8、[907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums/)「中等」

明白题目的意思，但是做不出来，leecode上有解题思路，目前看不懂，暂时先跳过吧。2022-02-06

---

## 3、双指针

参考文章：https://mp.weixin.qq.com/s/C4ZFwyJThBJdyqbNo87isQ
参考文章：https://labuladong.gitee.io/algo/2/21/59/

```apl
核心思想
先掌握C++的链表数据结构吧，怎么使用都不会，还写个锤子算法
```

### 1、[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)「简单」

题目意思就是给你一个单链表，判断它是否包含环
下面的方法并没有使用到双指针

```c++
#include<iostream>
#include <map>
#include <unordered_set>
using namespace std;

//C++里面应该是没有默认的链表结构，下面的struct是需要自己创建的，这里创建的结构体是leecode帮我们创建的。所以可以不用管它，在hasCycle函数中直接使用它就行
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL){}
};

bool hasCycle(ListNode *head) {
    unordered_set<ListNode*> seen;//注意这里定义了一个无序集合，需要导入相应头文件 
    while (head != nullptr) {
        if (seen.count(head)) {//如果集合中有这个head，那么就说明有环
            return true;//这里的思路很简单，就是用集合记录每一个head的遍历情况
          //下面会记录(insert)当前head的遍历，下一次再次if判断时，如果成环，就会进入if 返回true即可
          //如果没有成环，将在最后一个head被insert之后，结束whiel
        }
        seen.insert(head);
        head = head->next;
    }
    return false;
}
//这里感觉用map来替换unordered_set 也是可以的，但是我替换后一直报错，后面再试试
```

使用双指针求解
思路：在循环中用两个指针来遍历，一个慢指针slow，一个快指针，当存在环时，快指针会和慢指针相遇，相遇则返回true，不相遇，则返回false。但是利用双指针求解超出leecode时间限制了

```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL){}
};

//这里的方法虽然能算出来，但是时间复杂度超限了
bool hasCycle(ListNode *head) {
    ListNode *fast = nullptr, *slow = nullptr;
    while(head != nullptr){
        fast = head->next->next;
        slow = head->next;
        if (fast == slow) {//why 判断要放在下面，放在while开头处不对
            return true;
        }
    }
    return false;
}
```

### 2、[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)「中等」

下面的题没有用到双指针，感觉双指针不台适合这个题，双指针做起来不太好理解

```c++
思路很简单，利用hash，记录遍历到的节点，当再次遍历到第一个已遍历过的节点，则说明该节点是环的起始位置
#include<iostream>
#include <unordered_set>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode *detectCycle(ListNode *head) {
    unordered_set<ListNode *> visited;
    while (head != nullptr) {
        if (visited.count(head)) {//注意这行代码
            return head;
        }
        visited.insert(head);
        head = head->next;
    }
    return nullptr;
}
```

### 3、[876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)「简单」

```apl
寻找链表中点的一个重要作用是对链表进行归并排序。
回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。
但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序的具体内容本文就不具体展开了。
from: https://labuladong.gitee.io/algo/2/21/59/
```

我的思路是，遍历所有节点，用count记录总的节点数，然后count%2 能整除 中间结点就是centerIndex+1；不能整除，中间结点就是centerIndex；然后再次遍历到centerIndex 返回该节点

这个题如果用双指针来做，会更加巧妙。快指针的速度是慢指针的2倍，所以当快指针走到最后一个结点时，慢指针正好走到中间的位置。虽然巧妙，但是leecode做题时，提示超出时间限制。。。

```c++
ListNode* middleNode(ListNode* head) {
    ListNode *slow;
    ListNode *fast;
    fast = head;
    slow = head;
    while(fast != nullptr && fast->next != nullptr){//注意这里的条件
        fast = head->next->next;
        slow = head->next;
    }
    return slow;
}
```

方法一：数组
思路和算法

链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]
当 n==3时，3/2 = 1.5=1 (从0开始)，当n=4时，4/2=2，

```c++
//这是leecode代码
ListNode* middleNode(ListNode* head) {
    vector<ListNode*> A = {head};
    while (A.back()->next != NULL)
    A.push_back(A.back()->next);
    return A[A.size() / 2];
}

//下面是我写的代码
ListNode* middleNode(ListNode* head) {
    vector<ListNode *>arr;
    while(head != nullptr){
        arr.push_back(head);
        head = head->next;
    }
    int center = arr.size()/2;
    return arr[center];
}
```

### 4、[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)「中等」

双指针可以求解，但是我没看懂。

```c++
下面的代码是来自：https://labuladong.gitee.io/algo/2/21/59/   并非c++代码
ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode fast, slow;
    fast = slow = head;
    // 快指针先前进 n 步
    while (n-- > 0) {
        fast = fast.next;
    }
    if (fast == null) {
        // 如果此时快指针走到头了，
        // 说明倒数第 n 个节点就是第一个节点
        return head.next;
    }
    // 让慢指针和快指针同步向前
    while (fast != null && fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }
    // slow.next 就是倒数第 n 个节点，删除它
    slow.next = slow.next.next;
    return head;
}
```



---

## 4、BFS

BFS(Broad First Search)即 广度优先搜索

参考文章：https://mp.weixin.qq.com/s/WH_XGm1-w5882PnenymZ7g

```apl
核心思想:问最短路径
一遍没看懂没关系，可以自己多动手动脑，比划比划。
```

### 1、[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)「简单」

在看这个题解之前，你先需要学会二叉树的后序遍历，见：[leetcode 145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/jian-dan-yi-dong-javac-pythonjs-er-cha-s-btwx/)
下面讲一下二叉树的三种遍历：前序遍历、中序遍历、后序遍历，如下图
<img src="./algorithm/treeNode_bianli_desc.png" alt="treeNode_bianli_desc" style="zoom:50%;" />

二叉树深度优先遍历
前序遍历： 144.二叉树的前序遍历
后序遍历： 145.二叉树的后序遍历
中序遍历： 94.二叉树的中序遍历

二叉树广度优先遍历
层序遍历：102.二叉树的层序遍历


---

## 5、DFS 

DFS(Depth First Search)即 深度优先搜索

参考文章：https://www.bilibili.com/video/BV1P5411N7Xc

```apl
核心思想
```

---

## 6、滑动窗口

参考文章：https://www.cnblogs.com/huansky/p/13488234.html
参考文章：https://labuladong.gitee.io/algo/1/11/

```apl
核心思想
先看双指针，在看滑动窗口，它们是递进关系。

```

子数组最大平均数 I
长度为三且各自负不同的子字符串
存在重复元素II
替换后的最长重复字符
重复的DNA序列
水果成篮



---

## 7、并查集

参考文章：https://segmentfault.com/a/1190000004023326

```apl
核心思想
```

---



## redo笔记

### 1、前缀和

[1893. 检查是否区域内所有整数都被覆盖](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/)


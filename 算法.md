# 算法

## 1、前缀和

前缀和，参看这篇文章：https://mp.weixin.qq.com/s/r-6Yfp2qn_x8nKJMVirdyQ
核心思想：

```apl
前缀和的意思就是：一个数列的总和
比如：S5 = a1+a2+a3+a4+a5;  S2 = a1+a2;
由于 S5-S2 = a3+a4+a5 注意！这里的a3~a5就是一个连续的子数组
这个过程就和我们做题用到的前缀和思想类似。我们的前缀和数组里保存的就是前 n 项的和
```

了解这种思路后，就可以相对容易的完成下列算法题（关键还是要去coding，不然肯定是不做的）

### 1、leecode 724 寻找数组的中心索引（简单）

略

### 2、leecode 1 两数之和（简单）

略

### 3、leecode 560 和为K的子数组（中等）

暴力解法

```c++
#include<iostream>
#include<vector>
using namespace std;

int sumKSubArray(vector<int>&nums, int k){//暴力解法【时间复杂度 O(n)方】
    int count = 0;
    int subSum = 0;
    for (int i = 0; i < nums.size(); i++) {
        for (int j = i; j < nums.size(); j++) {
            subSum += nums[j];
            if (subSum == k) {
                count++;
            }
        }
        subSum = 0;
    }
    return count;
}

int main(){
    vector<int>intArr;
    intArr.push_back(1);
    intArr.push_back(-1);
    intArr.push_back(0);
    cout <<sumKSubArray(intArr, 0)<<endl;
    return 0;
}
```

hash+前缀和 解法 这个题并没有完全搞懂！

```c++
#include<iostream>
#include<vector>
#include<map>
using namespace std;

int sumKSubArray(vector<int>&nums, int k){
    int count = 0;
    map<int, int> mapPresum;
    mapPresum[0] = 1;//这里的值是为了覆盖k=0的情况
    int presum = 0;
    for(int i = 0; i < nums.size(); i ++){
        presum += nums[i];
        if (mapPresum[presum-k]) {//这里也不是很好理解
            count += mapPresum[presum -k];//这里也不是很好理解
        }
        if (mapPresum[presum]) {
            mapPresum[presum] += 1;
        } else {
            mapPresum[presum] = 1;
        }
    }
    
    return count;
}

int main(){
    vector<int>intArr;
    intArr.push_back(1);
    intArr.push_back(-1);
    intArr.push_back(0);
    cout <<sumKSubArray(intArr, 0)<<endl;
    return 0;
}

```



### 4、leecode 1248 统计优美子数组（中等）

### 5、leecode 974 和可被K整除的子数组（中等）

### 6、leecode 523 连续的子数组和（中等）

### 7、leecode 930 和相同的二元子数组（中等）

